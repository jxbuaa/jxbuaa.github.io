<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>X小Mickey&#39;Blog</title>
  
  <subtitle>Stay Foolish &amp;&amp; Stay Hungry</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://jxbuaa.github.io/"/>
  <updated>2022-02-09T07:26:28.016Z</updated>
  <id>http://jxbuaa.github.io/</id>
  
  <author>
    <name>X小Mickey</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Linux进程调度器</title>
    <link href="http://jxbuaa.github.io/2022/02/Linux%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E5%99%A8/"/>
    <id>http://jxbuaa.github.io/2022/02/Linux进程调度器/</id>
    <published>2022-02-25T03:00:00.000Z</published>
    <updated>2022-02-09T07:26:28.016Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言">前言</h1><p>本文梳理了Linux进程调度器的框架结构，旨在通过本文阐述Linux进程调度器的基本工作原理。 用一句话概括<strong>调度</strong>：cpu按照特定的规则（调度器：CFS / RT / DL）在特定的时机（主调度+周期调度）通过特定的数据结构（priority queue / RB-tree）对数据对象（进程描述符task_struct-&gt;sched_*_entity）的增删改查，以实现对系统任务（task）的调度管理</p><span id="more"></span><p>内核版本：linux-4.9.140</p><h1 id="什么是调度器">什么是调度器</h1><blockquote><p>The scheduling activity is carried out by a process called scheduler. Schedulers are often designed so as to keep all computer resources busy (as in load balancing), allow multiple users to share system resources effectively, or to achieve a target quality-of-service.</p></blockquote>如图1，调度器是按照特定的策略高效的利用有限的计算资源 <img src="https://wx3.sinaimg.cn/mw690/6a6ccd8fly1gz6d1l2w4tj20rb0ekwfc.jpg" alt="图1" /><p align="center">图1 调度器</p><h2 id="调度对象">调度对象</h2>从内核的角度，调度器管理的是使用task struct数据结构描述的调度对象 调度对象均使用<code>_do_fork()</code>接口创建，代入不同flag的创建不同属性的调度对象，从应用层的角度表现出的就是线程和进程的区别 - 进程创建流程 fork creates a duplicate copy of the calling process as its child. The exec() family of functions replaces the current process image with a new process image wait and exit <img src="https://wx2.sinaimg.cn/mw690/6a6ccd8fly1gz6d1p7hbgj20qn0gyjsq.jpg" alt="图2" /><p align="center">图2 进程创建流程</p><ul><li>线程创建流程 <img src="https://wx3.sinaimg.cn/mw690/6a6ccd8fly1gz6d6puj9nj20hu0itjs2.jpg" alt="图3" /><p align="center">图3 线程创建流程</p></li><li>线程进程创建原理 <img src="https://wx4.sinaimg.cn/mw690/6a6ccd8fly1gz6d6tcns7j20hs0p8dk5.jpg" alt="图4" /><p align="center">图4 进程线程创建接口</p></li><li>User Space</li><li>创建进程（fork）</li><li>创建应用层线程（pthread_create）</li><li>Kernel Space</li><li>创建内核层线程（kernel_thread）</li><li>均调用_do_fork，只是flag不一样</li><li>进程是资源分配的最小单元</li><li>线程是CPU调度的最小单元（从内核角度，线程可以看作一种特殊的进程）</li><li>调度对象的本质：进程描述符struct task_struct数据结构中的struct sched_entity se</li><li>一共包括三类调度实体</li><li>struct sched_entity se;</li><li>struct sched_rt_entity rt;</li><li>struct sched_dl_entity dl;</li></ul><img src="https://wx3.sinaimg.cn/mw690/6a6ccd8fly1gz6d6w9c76j20nr0hn3za.jpg" alt="图5" /><p align="center">图5 进程线程创建原理</p><h1 id="如何选择调度器">如何选择调度器</h1><h2 id="调度器框架">调度器框架</h2><p>为了使代码可维护性高、解耦，内核代码中大量使用了面向对象的设计思想，在调度器的设计中也不例外。尽管C没有像C++拥有专有的面向对象的语言特性，但并不妨碍C使用面向对象的思想设计框架结构。</p>在调度器的框架结构设计中，使用struct中的函数指针（相当于C++中的虚函数表）实现&quot;多态&quot;概念，搭好框架后，只需要按照各自的调度功能需求实现函数指针的接口即可实现不同功能特性的调度器，这样的设计思想和技巧在内核中随处可见。 <img src="https://wx2.sinaimg.cn/mw690/6a6ccd8fly1gz6d87gw0aj20z60jagpv.jpg" alt="图6" /><p align="center">图6 调度器框架</p><p>内核中一共实现了五种调度器，按照调度器优先级依次是：stop_sched_class, dl_sched_class, rt_sched_class, fair_sched_class, idle_sched_class</p><ul><li>stop_sched_class和idle_sched_class由内核使用，没有应用层vfs交互调整接口</li><li>stop_sched_class：在cpu hotplug时使用，用于停止当前cpu的处理任务</li><li>idle_sched_class：cpu空闲运行idle进程，arm64执汇编指令// WFI may enter a low-power mode</li></ul><p>其中暴露给应用层的调度器分别是：DL, RT, CFS</p><table><thead><tr class="header"><th align="center"></th><th align="center">DL</th><th align="center">RT</th><th align="center">CFS</th></tr></thead><tbody><tr class="odd"><td align="center">调度策略</td><td align="center">SCHED_DEADLINE</td><td align="center">SCHED_FIFO，SCHED_RR</td><td align="center">SCHED_NORMAL，SCHED_BATCH，SCHED_IDLE</td></tr><tr class="even"><td align="center">内核态优先级</td><td align="center">-1（无优先级）</td><td align="center">0 - 99</td><td align="center">100 - 139 （120 + nice值(-20 ~ 19)）</td></tr></tbody></table><ul><li>SCHED_BATCH策略，用于非交互式任务的批处理，这些任务会在一段时间内不间断地运行</li><li>SCHED_NORMAL策略（在用户空间中称为SCHED_OTHER），适用于用于Linux环境中运行的大多数任务</li><li>SCHED_IDLE策略是为系统中优先级最低的任务设计的，只有在没有其他任务可运行时，这些任务才有机会运行。</li></ul><h2 id="核心数据结构">核心数据结构</h2>为了实现不同调度器的特点，内核采用了红黑树和优先级队列数据结构进行管理，如图7所示： <img src="https://wx2.sinaimg.cn/mw690/6a6ccd8fly1gz6d8a214jj20ya0ifacb.jpg" alt="图7" /><p align="center">图7 核心数据结构</p><h2 id="cfs调度器">CFS调度器</h2><p>CFS：Completely Fair Scheduler调度器有三要素：priority(nice) → weight → vruntime nice值（-20 ~ 19）为应用层进程属性 ，进程nice值越高，表示该进程越“友好”，进程优先级越低，反之则进程优先级越高</p><p>nice值到内核层进程权重的关系为： <span class="math display">\[weight = \frac{1024}{1.25^{nice}}\]</span> 一般默认属性创建的进程<strong>nice = 0</strong>，对应的<strong>weight = NICE_0_LOAD(1024)</strong></p><p>通过计算可以知道，这么设计的初衷，是为了保证每降低进程一个单位nice值，将使其多获得10% 的cpu占用时间</p><p>通过权重值就可以计算调度周期内需要分配给进程的运行时间片 <span class="math display">\[分配给进程的时间 = \frac{进程的权重}{就绪队列（runqueue）所有进程权重之和} * 调度周期\]</span> 注意，CFS调度器下的调度周期并不是固定值，伪代码逻辑如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sched_nr_latency = (sysctl_sched_latency + sysctl_sched_min_granularity – <span class="number">1</span>) / sysctl_sched_min_granularity</span><br><span class="line"><span class="keyword">if</span> (nr_running &gt; sched_nr_latency) &#123;</span><br><span class="line">    sched_period = nr_running  * sched_min_granularity_ns;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    sched_period = sysctl_sched_latency;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当进程数量nr_running超过sched_nr_latency时，为了保证进程的最小执行时间sysctl_sched_min_granularity（避免因为分配的时间片过小造成频繁的调度开销），会动态调整当前的调度周期<code>sched_period = nr_running * sched_min_granularity_ns</code>；否则，调度周期<code>sched_period = sysctl_sched_latency</code></p><ul><li>进程最小执行时间：/proc/sys/kernel/sched_min_granularity_ns</li><li>CFS调度延迟：/proc/sys/kernel/sched_latency_ns</li></ul><p>在调度算法上，CFS调度器引入了<strong>虚拟运行时间vruntime</strong>的概念，将优先级nice和实时运行时间两个维度通过公式转换到了一个维度 <span class="math display">\[vruntime(虚拟运行时间) = wall\_time (实际运行时间) * \frac{NICE\_0\_LOAD}{weight}\]</span> <span class="math display">\[vruntime(虚拟运行时间) = wall\_time (实际运行时间) * \frac{1024}{\frac{1024}{1.25^{nice}}}\]</span> <span class="math display">\[vruntime(虚拟运行时间) = wall\_time (实际运行时间) * 1.25^{nice}\]</span></p><blockquote><p>推出: 进程nice越大 → 优先级越低 → vruntime增长越快 → 在相同vruntime下实际占用cpu时间越短 nice = 0时， vruntime(虚拟运行时间) = wall_time (实际运行时间)</p></blockquote><p>同时，根据上述转换公式，可以得到分配给进程的<strong>虚拟时间片</strong>计算公式 <span class="math display">\[分配给进程的时间(virtual) = \frac{进程的权重 * 调度周期}{就绪队列（runqueue）所有进程权重之和} * \frac{NICE\_0\_LOAD}{weight}\]</span> <span class="math display">\[分配给进程的时间(virtual) = \frac{调度周期 * NICE\_0\_LOAD}{就绪队列（runqueue）所有进程权重之和}\]</span> 通过上述公式，可以得到分配给进程的虚拟时间片是个与<strong>调度周期相关的固定值</strong>，即在一个调度周期内，该cpu调度队列中的进程任务分配到的<strong>虚拟时间片相同</strong> 结合上述理论，以单核CPU为例</p><table><thead><tr class="header"><th align="center"></th><th align="center">nice</th><th align="center">权重weight</th><th align="center">调度周期period</th><th align="center">真实时间片ideal_runtime</th><th align="center">虚拟时间片</th><th align="center">进程执行1ms后vruntime值</th></tr></thead><tbody><tr class="odd"><td align="center">进程A</td><td align="center">0</td><td align="center">1024</td><td align="center">6ms</td><td align="center">3.3ms</td><td align="center">3.3ms</td><td align="center">1ms</td></tr><tr class="even"><td align="center">进程B</td><td align="center">1</td><td align="center">820</td><td align="center">6ms</td><td align="center">2.7ms</td><td align="center">3.3ms</td><td align="center">1.25ms</td></tr></tbody></table><ul><li>进程A：</li><li>权重weight = 1024 / 1.250 = 1024</li><li>调度周期period = sysctl_sched_latency * （1 + log1）= sysctl_sched_latency = 6ms</li><li>真实时间片ideal_runtime = 6ms * 1024 / (1024 + 820) = 3.3ms</li><li>虚拟时间片 = 3.3ms * 1.250 = 3.3ms</li><li>真实步进1ms = 虚拟步进1ms * 1.250 = 虚拟步进1ms</li><li>进程B：</li><li>权重weight = 1024 / 1.251 = 820</li><li>调度周期period = sysctl_sched_latency * （1 + log1）= sysctl_sched_latency = 6ms</li><li>真实时间片ideal_runtime = 6ms * 820 / (1024 + 820) = 2.7ms</li><li>虚拟时间片 = 2.7ms * 1.251 = 3.3ms</li><li>真实步进1ms = 虚拟步进1ms * 1.251 = 虚拟步进1.25ms</li></ul><p>如上计算，进程A和B的真实时间片根据nice值（权重weight）分配调度周期，二者分配的虚拟时间片相同；</p><p>在1ms真实步进下，进程B的虚拟步进（1.25ms）大于进程A（1ms），更快的用完分配的虚拟时间片，执行时间更短、更快被换出，也即：nice值越高，占用CPU更短</p><h2 id="rt调度器">RT调度器</h2><p>RT：Real Time调度器要素：priority | timeslice（/proc/sys/kernel/sched_rr_timeslice_ms）</p><ul><li>不相同优先级的实时调度线程</li><li>不论是SCHED_RR还是SCHED_FIFO，高优先级线程均能对低优先级线程实施抢占，且在主动放弃CPU之前不会释放占用</li><li>相同优先级的实时调度线程</li><li>如果同为SCHED_RR线程，线程之间分享时间片，轮转运行。</li><li>如果同为SCHED_FIFO线程，其中之一（谁先运行）会一直运行直到到其主动释放占用CPU，另一个才会执行。即同优先级不会分享时间片</li><li>两个分别为SCHED_RR，SCHED_FIFO线程</li><li>SCHED_RR线程会分享时间片，即时间片用完后会放弃占用CPU，被SCHED_FIFO线程占用，SCHED_FIFO线程占用后不会和SCHED_RR线程分享时间片，会一直运行到其主动释放占用后，SCHED_RR线程才会再次执行</li><li>两个线程一个为实时调用线程，一个为非实时调用线程、</li><li>实时线程不论是何优先级（&gt;0），何种调度方式，都能对非实时线程实施抢占，且不会对非实时线程共享时间片</li></ul><p>另： - Round-Robin调度策略的时间片由/proc/sys/kernel/sched_rr_timeslice_ms决定（timeslice必须是tick倍数(1 / CONFIG_HZ_250 = 4ms)） - 输入为ms，输出为滴答数，即写入的参数单位是ms，读出时的单位是当前系统的jiffies - RT进程和普通进程之间存在分配带宽的比例，默认情况是RT:CFS=95:5。 - 可通过/proc/sys/kernel/sched_rt_period_us和/proc/sys/kernel/sched_rt_runtime_us来设置 - 如果设置sched_rt_runtime_us为-1（慎用），则禁止对RT进程的带宽限制，即如果存在RT进程会占满整个CPU且该CPU不在会有调度CFS进程的机会</p><h2 id="dl调度器">DL调度器</h2><p>DL：Deadline调度器要素：runtime | deadline | period 在period周期内，抵达deadline前，执行runtime时间 带宽bw = runtime / period 要求1us &lt; runtime &lt;= deadline &lt;= period (if period != 0)</p><img src="https://wx2.sinaimg.cn/mw690/6a6ccd8fly1gz6d8ciy19j20eh041dg1.jpg" alt="图8" /><p align="center">图8 DL调度器要素</p><p>对比在CFS调度器，当任务总数增加时，单个任务其在一个调度周期内所能获得的时间片会相应减少直到最小执行时间sched_min_granularity_ns DL调度中的任务的需求就不会受到系统中其他任务的影响，这个特性是Deadline调度器策略最大的优势</p><p>测试：3个线程绑定到core 6，7，三要素属性分别为：[50, 100, 100]; [50, 100, 100]; [20, 100, 100]，cpu占用情况如图9所示：core6 50%；core7 50%；core6 20%</p><img src="https://wx1.sinaimg.cn/mw690/6a6ccd8fly1gz6d8f7c2wj21ep0d9q7y.jpg" alt="图9" /><p align="center">图9 DL调度器测试</p><h1 id="什么时候发起调度">什么时候发起调度</h1><p>调度器并不是管家式的管理方式（由专门进程任务进行管理），而是将调度的判断、换出等操作嵌进了整个内核的运转中 这里以arm体系结构为例，介绍Arm体系结构相关，并引入介绍“主调度器”和“周期调度器”</p><h2 id="arm体系结构相关">Arm体系结构相关</h2><img src="https://wx1.sinaimg.cn/mw690/6a6ccd8fly1gz6d8hck0tj20vj0jx76z.jpg" alt="图10" /><p align="center">图10 ARMv8异常级别</p><ul><li>EL0：应用程序运行（用户空间）</li><li>EL1：操作系统内核和相关功能</li><li>EL2：Hypervisor（虚拟化相关）</li><li>EL3：Noraml world和Secure world的切换 (ARM Trusted Firmware)</li></ul><img src="https://wx2.sinaimg.cn/mw690/6a6ccd8fly1gz6dcxba2qj216j0q5juq.jpg" alt="图11" /><p align="center">图11 ARMv8异常处理流程</p><h2 id="主调度器">“主调度器”</h2><img src="https://wx3.sinaimg.cn/mw690/6a6ccd8fly1gz6dczphf8j20mi0gqdgt.jpg" alt="图12" /><p align="center">图12 主调度器流程</p><h2 id="周期调度器">“周期调度器”</h2><img src="https://wx2.sinaimg.cn/mw690/6a6ccd8fly1gz6dd27hehj213c09s753.jpg" alt="图13" /><p align="center">图13 周期度器流程</p><h1 id="调度器如何调度">调度器如何调度</h1><h2 id="上下文切换">上下文切换</h2><img src="https://wx3.sinaimg.cn/mw690/6a6ccd8fly1gz6dczphf8j20mi0gqdgt.jpg" alt="图12" /><p align="center">图14 上下文切换流程</p><h1 id="q-a">Q &amp; A</h1><ol style="list-style-type: decimal"><li>主调度器和周期调度器是否冲突？ 不冲突，只是调度时机不同，相辅相成，互为补充</li><li>内核任务（ 内核线程，内核系统调用）是否可以被抢占？ 在使能内核抢占开关CONFIG_PREEMPTION=y后，且满足抢占计数preempt_count == 0（防止抢占嵌套）时，可以被抢占</li><li>TIF_NEED_RESCHED的内涵？ 在调度器决策出当前进程需要被换出时设置进程描述符的对应flag，在下个调度时机到来时藉由该flag决定是否启动schedule流程，启动schedule后再由class-&gt;pick_next_task接口返回值决定该进程是否换出</li><li>何时会设置TIF_NEED_RESCHED标志？ 通用场景：有进程待唤醒时，当前进程满足被抢占条件；修改正在运行的进程优先级；进程主动放弃cpu（yield）；特殊情况下的强制cpu reschedule 针对不同调度器的具体场景： CFS：当前进程时间片耗尽；当前运行进程的调度策略转换成CFS时； DL：下个被pick的进程deadline更小且当前进程可以被迁移时；当前运行进程的调度策略转换成DL时；当前进程runtime耗尽等</li><li>当一个进程从休眠状态唤醒时，是否会立即被CPU执行？ 不会。新唤醒的进程会被入列到对应cpu runqueue，同时设置当前进程TIF_NEED_RESCHED，在下个调度时机到来时，启动schedule流程</li><li>调度器框架的函数指针，分别实现功能是？ *next：指向下一个调度器，用于遍历调度器接口时使用，应用场景举例：调度pick下一个任务时 *enqueue_task：将task加入对应的调度器数据结构，应用场景举例：创建进程、调整优先级等 *dequeue_task：将task从对应的调度器数据结构移除，应用场景举例：进程结束等 *pick_next_task：挑选下一个需要换入的task（具体换入策略由各自调度器实现），在触发schedule时执行 *put_prev_task：不同调度器有不同实现：cfs：将换出的task，归置到runqueue队尾；dl：则是将当前执行任务归置到可供迁移到其他cpu的红黑树节点上。应用场景举例：调整当前运行进程的优先级时 *task_tick：周期调度器中断handler的实现，更新当前进程的时间相关参数（cfs时间片，dl调度器runtime &amp; deadline）并决定是否resched_curr …</li></ol><h1 id="工具介绍">工具介绍</h1><p>trace-cmd &amp; kernelshark</p><h1 id="参考文献">参考文献</h1><p>Linux进程管理 (9)实时调度类分析，以及FIFO和RR对比实验 https://www.cnblogs.com/arnoldlu/p/9025981.html Linux进程调度策略 https://www.cnblogs.com/jacklikedogs/p/4029825.html 试谈Linux下的线程调度-『Linux 源码解析（一）』 https://zhuanlan.zhihu.com/p/58868634 Using KernelShark to analyze the real-time scheduler https://lwn.net/Articles/425583/ ftrace利器之trace-cmd和kernelshark https://www.cnblogs.com/arnoldlu/p/9014365.html kernelshark使用说明 https://kernelshark.org/Documentation.html 进程的创建 https://zhuanlan.zhihu.com/p/185751680 AArch64 Exception and Interrupt Handling https://developer.arm.com/documentation/100933/0100/ linux内核同步机制-RCU（1）系列 https://zhuanlan.zhihu.com/p/347279156 linux程序是如何开始运行的 https://zhuanlan.zhihu.com/p/337477747 内存屏障（Memory Barrier）究竟是个什么鬼 https://zhuanlan.zhihu.com/p/125737864 linux调度子系统6 - 周期调度 timer setup https://zhuanlan.zhihu.com/p/363787529 CFS调度器（1）-基本原理 http://www.wowotech.net/process_management/447.html</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;本文梳理了Linux进程调度器的框架结构，旨在通过本文阐述Linux进程调度器的基本工作原理。 用一句话概括&lt;strong&gt;调度&lt;/strong&gt;：cpu按照特定的规则（调度器：CFS / RT / DL）在特定的时机（主调度+周期调度）通过特定的数据结构（priority queue / RB-tree）对数据对象（进程描述符task_struct-&amp;gt;sched_*_entity）的增删改查，以实现对系统任务（task）的调度管理&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://jxbuaa.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Linux" scheme="http://jxbuaa.github.io/tags/Linux/"/>
    
      <category term="Scheduler" scheme="http://jxbuaa.github.io/tags/Scheduler/"/>
    
  </entry>
  
  <entry>
    <title>面试题目梳理</title>
    <link href="http://jxbuaa.github.io/2021/08/%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE%E6%A2%B3%E7%90%86/"/>
    <id>http://jxbuaa.github.io/2021/08/面试题目梳理/</id>
    <published>2021-08-28T08:49:25.000Z</published>
    <updated>2021-09-17T06:58:00.226Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言">前言</h1><p>正值秋招面试季，梳理了一些常见的面试题。 <span id="more"></span></p><h1 id="c知识点">C++知识点</h1><ul><li><strong>解释下封装、继承和多态</strong> 这里主要说下虚函数表和虚函数指针的使用特点，了解后基本能够掌握多态的原理</li></ul><p><strong>关于虚函数表和虚函数指针</strong></p><ul><li><p>静态绑定：指在程序编译过程中，把函数调用与响应调用所需的代码结合的过程，称为静态绑定，发生在编译期 非虚成员函数属于静态绑定：编译器在编译期间，根据指针（或对象）的类型完成了绑定</p></li><li><p>动态绑定：指在执行期间判断所引用对象的实际类型，根据实际的类型调用其相应的方法。程序运行过程中，把函数调用与响应调用所需的代码相结合的过程称为动态绑定，发生于运行期</p></li><li><p>C++标准规格说明书中说到，<font color=red>编译器</font>必须要保证<font color=red>虚函数表的指针</font>存在于<font color=red>对象实例中最前面</font>的位置（这是为了保证正确取到虚函数的偏移量）</p></li><li><p><font color=red>虚函数</font>是通过<font color=red>虚函数表</font>实现，这个表中<font color=red>仅</font>记录<font color=red>虚函数的地址</font> <font color=red>编译器</font>会为每个有<font color=red>虚函数的类</font>创建一个<font color=red>虚函数表</font>，该虚函数表将被该类<font color=red>所有对象共享</font> 虚函数表是一块连续的内存，每个内存单元中记录一个JMP指令的地址</p></li><li><p>类的每个虚成员占据虚函数表中的一行，如果类中有N个虚函数，那么其虚函数表将有N*4字节（32位）的大小</p></li><li><p>在单继承中，Child类覆盖Base类中的同名虚函数，在Child类的虚函数表中体现为对应位置被Child类中的新函数替换，而没有被覆盖的Base类的虚函数则顺次继承不发生变化 对于派生类Child自己的虚函数，则顺次添加到Child类虚函数表后面</p></li><li><p>向上类型转换：将派生类指针或引用转换为基类的指针或引用，安全、隐式的 向下类型转换：将基类指针或引用转换为派生类指针或引用，非安全需要程序员保证 向上转型后通过基类的指针、引用本质类型是属于基类（虚函数表指针却指向转换前类的虚函数表地址），只能访问基类成员和成员函数，如果是基类存在虚函数则会触发多态：根据转型前的对象类的虚函数表指针决定 <font color=red>如果是对象类型（非指针、引用）向上转型，则是完全转型</font>，虚函数表指针指向转换后类的虚函数表地址</p></li><li><p>对类进行实例化时，在<font color=red>构造函数执行时</font>会对<font color=red>虚表指针</font>初始化，并且存在对象内存布局的最前面 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;Base&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">2</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> :</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;Child&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;Child test&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> c = <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">  Base *bp = <span class="keyword">new</span> <span class="built_in">Child</span>();</span><br><span class="line">  Base b1;</span><br><span class="line">  Child c1, c2;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;Child vfptr = &quot;</span> &lt;&lt; *((<span class="keyword">int</span> *)&amp;c1) &lt;&lt; endl;<span class="comment">// 取虚函数表地址值*((int *)&amp;c1)</span></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;Child vfptr = &quot;</span> &lt;&lt; *((<span class="keyword">int</span> *)&amp;c2) &lt;&lt; endl;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;Child vfptr = &quot;</span> &lt;&lt; *((<span class="keyword">int</span> *)bp) &lt;&lt; endl;<span class="comment">// 触发多态bp的虚函数表 = cp的虚函数表 = Child类的虚函数表</span></span><br><span class="line">  Base b2 = <span class="keyword">static_cast</span>&lt;Base&gt;(c1);</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;Base vfptr = &quot;</span> &lt;&lt; *((<span class="keyword">int</span> *)&amp;b2) &lt;&lt; endl;<span class="comment">// 静态对象类型转换不触发多态，b2的虚函数表 = Base类的虚函数表</span></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;Base vfptr = &quot;</span> &lt;&lt; *((<span class="keyword">int</span> *)&amp;b1) &lt;&lt; endl;</span><br><span class="line">  bp-&gt;<span class="built_in">func</span>();<span class="comment">// 触发多态</span></span><br><span class="line">  b2.<span class="built_in">func</span>();<span class="comment">// 不触发多态</span></span><br><span class="line">  <span class="comment">// bp-&gt;test();  // error: ‘class Base’ has no member named ‘test’</span></span><br><span class="line"></span><br><span class="line">  Base *bp1;</span><br><span class="line">  Child *cp1 = <span class="keyword">new</span> <span class="built_in">Child</span>();</span><br><span class="line">  bp1 = <span class="keyword">reinterpret_cast</span>&lt;Base *&gt;(cp1);</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;Child vfptr = &quot;</span> &lt;&lt; *((<span class="keyword">int</span> *)bp1) &lt;&lt; endl;<span class="comment">// 触发多态bp1的虚函数表 = cp1的虚函数表 = Child类的虚函数表</span></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;Child vfptr = &quot;</span> &lt;&lt; *((<span class="keyword">int</span> *)cp1) &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$ ./test</span><br><span class="line">Child vfptr = <span class="number">432614704</span></span><br><span class="line">Child vfptr = <span class="number">432614704</span></span><br><span class="line">Child vfptr = <span class="number">432614704</span></span><br><span class="line">Base vfptr = <span class="number">432614728</span></span><br><span class="line">Base vfptr = <span class="number">432614728</span></span><br><span class="line">Child</span><br><span class="line">Base</span><br><span class="line">Child vfptr = <span class="number">432614704</span></span><br><span class="line">Child vfptr = <span class="number">432614704</span></span><br></pre></td></tr></table></figure></p></li><li><p><strong>是否了解设计模式</strong> 对设计模式的掌握是判断候选人能否快速切入项目的一个重要标准 一般应届生候选人接触具备良好中间件的大型工程项目的机会并不会太多，因此如果能够写出几个常见的设计模式基本会让面试官眼前一亮 <strong>务必掌握</strong>：单例设计模式（饿汉式的线程安全double check）、工厂设计模式、观察者设计模式、模板方法设计模式等 推荐设计模式网站：https://refactoringguru.cn/design-patterns/cpp</p></li><li><p>单例设计模式 — C11之后线程安全，饿汉式 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Singleton&amp; <span class="title">GetInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> Singleton instance;<span class="comment">// C++11之后保证了类型安全</span></span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Func</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;in singleton&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Singleton</span>() &#123;&#125;</span><br><span class="line">    <span class="built_in">Singleton</span>(<span class="keyword">const</span> Singleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    Singleton&amp; <span class="keyword">operator</span>= (<span class="keyword">const</span> Singleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p></li><li><p>单例设计模式 — 饿汉式，主要考察的是锁的double check的内涵和static的使用细节 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Singleton *<span class="title">GetInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance_ == <span class="literal">nullptr</span>) &#123;          <span class="comment">// 为了效率，避免每个线程进入都要加锁</span></span><br><span class="line">            <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">            <span class="keyword">if</span> (instance_ == <span class="literal">nullptr</span>) &#123;      <span class="comment">// 为了配合第一个if，如果不加这行，多个线程同时阻塞lock处，获取锁后会重复申请</span></span><br><span class="line">                instance_ = <span class="keyword">new</span> <span class="built_in">Singleton</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> instance_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Func</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;in singleton&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Singleton</span>() &#123;&#125;</span><br><span class="line">    <span class="built_in">Singleton</span>(<span class="keyword">const</span> Singleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    Singleton&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Singleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> Singleton* instance_;</span><br><span class="line">    <span class="keyword">static</span> std::mutex mutex_;</span><br><span class="line">&#125;;</span><br><span class="line">Singleton* Singleton::instance_ = <span class="literal">nullptr</span>;<span class="comment">// 注意static修饰的类成员变量的类外定义</span></span><br><span class="line">std::mutex Singleton::mutex_;</span><br></pre></td></tr></table></figure></p></li><li><p>单例设计模式 — 懒汉式 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">static</span> Singleton* <span class="title">GetInstance</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> instance_; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Func</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;in singleton&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="built_in">Singleton</span>() &#123;&#125;</span><br><span class="line">  <span class="built_in">Singleton</span>(<span class="keyword">const</span> Singleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  Singleton&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Singleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> Singleton* instance_;</span><br><span class="line">&#125;;</span><br><span class="line">Singleton* Singleton::instance_ = <span class="keyword">new</span> <span class="built_in">Singleton</span>();</span><br></pre></td></tr></table></figure></p></li><li><p>模板工厂设计模式，项目中参考使用的，该模板基本可以覆盖大部分工厂模式的需求 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Product</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Product</span>() &#123; cout &lt;&lt; <span class="string">&quot;base default construct&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">  <span class="built_in">Product</span>(<span class="keyword">int</span> in) &#123; cout &lt;&lt; <span class="string">&quot;base input construct &quot;</span> &lt;&lt; in &lt;&lt; endl; &#125;</span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">Product</span>() &#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Operation</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductA</span> :</span> <span class="keyword">public</span> Product &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Operation</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;A&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductB</span> :</span> <span class="keyword">public</span> Product &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Operation</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;B&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductC</span> :</span> <span class="keyword">public</span> Product &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">ProductC</span>(<span class="keyword">int</span> in) : <span class="built_in">Product</span>(in) &#123; cout &lt;&lt; <span class="string">&quot;construct C &quot;</span> &lt;&lt; in &lt;&lt; endl; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Operation</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;C&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果ClassType是带入参的构造函数，可采用自定义的ClassCreatorFunc</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> IdType, <span class="keyword">typename</span> ClassType,</span><br><span class="line">          <span class="keyword">typename</span> ClassCreatorFunc = ClassType* (*)()&gt;</span><br><span class="line">class Factory &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// 当Lambda向函数指针的转换时，编译器为Lambda的匿名类实现函数指针类型转换运算符</span></span><br><span class="line">  <span class="keyword">bool</span> <span class="built_in">Register</span>(<span class="keyword">const</span> IdType&amp; id, <span class="keyword">const</span> ClassCreatorFunc creator) &#123;</span><br><span class="line">    <span class="keyword">return</span> mp_.<span class="built_in">insert</span>(std::<span class="built_in">make_pair</span>(id, creator)).second;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">Unregister</span><span class="params">(<span class="keyword">const</span> IdType&amp; id)</span> </span>&#123; <span class="keyword">return</span> mp_.<span class="built_in">erase</span>(id) == <span class="number">1</span>; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span>... ArgsType&gt;</span><br><span class="line">  <span class="function">std::unique_ptr&lt;ClassType&gt; <span class="title">CreateObject</span><span class="params">(<span class="keyword">const</span> IdType&amp; id,</span></span></span><br><span class="line"><span class="params"><span class="function">                                          ArgsType&amp;&amp;... args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> it = mp_.<span class="built_in">find</span>(id);</span><br><span class="line">    <span class="keyword">if</span> (it != mp_.<span class="built_in">end</span>()) &#123;</span><br><span class="line">      <span class="keyword">return</span> std::unique_ptr&lt;ClassType&gt;(</span><br><span class="line">          (it-&gt;second)(std::forward&lt;ArgsType&gt;(args)...));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  std::unordered_map&lt;IdType, ClassCreatorFunc&gt; mp_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用方式</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Factory&lt;std::string, Product&gt; factory;</span><br><span class="line">  factory.<span class="built_in">Register</span>(<span class="string">&quot;A&quot;</span>, []() -&gt; Product* &#123; <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">ProductA</span>(); &#125;);<span class="comment">// 注意-&gt; Product*强调返回类型</span></span><br><span class="line">  factory.<span class="built_in">Register</span>(<span class="string">&quot;B&quot;</span>, []() -&gt; Product* &#123; <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">ProductB</span>(); &#125;);</span><br><span class="line">  <span class="keyword">auto</span> ptr = factory.<span class="built_in">CreateObject</span>(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">  ptr-&gt;<span class="built_in">Operation</span>();</span><br><span class="line"></span><br><span class="line">  Factory&lt;std::string, Product, Product* (*)(<span class="keyword">int</span> in)&gt; factory1;</span><br><span class="line">  <span class="comment">// 自定义的ClassCreatorFunc</span></span><br><span class="line">  factory1.<span class="built_in">Register</span>(<span class="string">&quot;C&quot;</span>, [](<span class="keyword">int</span> in) -&gt; Product* &#123; <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">ProductC</span>(in); &#125;);</span><br><span class="line">  <span class="keyword">auto</span> ptr1 = factory1.<span class="built_in">CreateObject</span>(<span class="string">&quot;C&quot;</span>, <span class="number">123</span>);  <span class="comment">// 123为C构造函数入参</span></span><br><span class="line">  ptr1-&gt;<span class="built_in">Operation</span>();</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li><li><p>观察者设计模式，经常使用的、很常见的设计模式，在异步通知中比较常见 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ObserverBase</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">ObserverBase</span>() &#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Update</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> :</span> <span class="keyword">public</span> ObserverBase &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Update</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;A&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> ObserverBase &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Update</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;B&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NotifyBase</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Attach</span><span class="params">(ObserverBase* ob)</span> </span>&#123; list_ob_.<span class="built_in">emplace_back</span>(ob); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Detach</span><span class="params">(ObserverBase* ob)</span> </span>&#123; list_ob_.<span class="built_in">remove</span>(ob); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Notify</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i : list_ob_) &#123;</span><br><span class="line">      i-&gt;<span class="built_in">Update</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  std::list&lt;ObserverBase*&gt; list_ob_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用方式</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ObserverBase* a = <span class="keyword">new</span> <span class="built_in">A</span>();</span><br><span class="line">  ObserverBase* b = <span class="keyword">new</span> <span class="built_in">B</span>();</span><br><span class="line">  NotifyBase n;</span><br><span class="line">  n.<span class="built_in">Attach</span>(a);</span><br><span class="line">  n.<span class="built_in">Notify</span>();</span><br><span class="line">  n.<span class="built_in">Attach</span>(b);</span><br><span class="line">  n.<span class="built_in">Notify</span>();</span><br><span class="line">  n.<span class="built_in">Detach</span>(a);</span><br><span class="line">  n.<span class="built_in">Notify</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li><li><p>模板方法设计模式，也很常见，例如线程池库中 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">BaseFunc</span>();</span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">Func1</span>();</span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">Func2</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">protected</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Func1</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Func2</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">BaseFunc</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;BaseFunc&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Concrete</span> :</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line"> <span class="keyword">protected</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Func1</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Func1&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Func2</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Func2&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p></li><li><p><strong>static关键字使用特点</strong></p></li><li>类外<ul><li>静态全局变量</li></ul><ol style="list-style-type: decimal"><li>存储在全局数据区，默认初始化为0</li><li>整个文件内可见，文件外不可见</li></ol><ul><li>静态局部变量</li></ul><ol style="list-style-type: decimal"><li>同样存储在全局数据区，默认初始化为0</li><li>在程序执行到该变量的声明处时被首次初始化，以后的函数调用不再进行初始化</li><li>始终驻留在全局数据区，直到程序运行结束，作用域为局部作用域</li></ol></li><li>类内<ul><li>静态成员变量为类的所有对象共享，在内存中只有一个副本</li><li>静态成员变量使用前必须类外初始化，否则会报“undefined reference to”</li><li>静态成员变量依然遵循public,protected,private访问规则</li><li>非静态成员函数<strong>可以</strong>访问静态成员变量和非静态成员变量</li><li>静态成员函数<strong>可以</strong>访问静态成员变量，<strong>不可以</strong>访问非静态成员变量和非静态成员函数，静态成员函数没有this指针</li><li>除了对象调用，还可以<code>类名::静态成员函数名（参数表）</code>调用类的静态成员函数</li></ul></li><li><p><strong>堆栈区别(堆和栈的生命周期)</strong></p></li></ul><table><thead><tr class="header"><th align="center"></th><th align="center">堆</th><th align="center">栈</th></tr></thead><tbody><tr class="odd"><td align="center">分配/回收方式</td><td align="center">new或者malloc，程序员自主管理</td><td align="center">编译器管理</td></tr><tr class="even"><td align="center">大小</td><td align="center">取决于内存大小</td><td align="center">有限制，不同系统不同，一般是MB级别</td></tr><tr class="odd"><td align="center">生长方向</td><td align="center">向着内存地址增加的方向增长</td><td align="center">向着内存地址减小的方向增长</td></tr><tr class="even"><td align="center">分配效率</td><td align="center">效率较低</td><td align="center">效率较高</td></tr></tbody></table><ul><li>如何解决栈溢出</li></ul><ol style="list-style-type: decimal"><li>减少局部变量的使用，必要时在堆上分配空间</li><li>函数入参尽量使用引用或者指针类型</li><li>非必要不使用函数递归</li></ol><ul><li><strong>new和malloc的区别</strong> 这个题重点考察的是new的原理步骤</li></ul><ol style="list-style-type: decimal"><li>operator new函数申请空间，内部调用malloc</li><li>placement new在该空间上调用构造函数</li><li>返回指针 另：malloc不保证类型安全，new可以保证类型安全</li></ol><ul><li><strong>vector迭代器什么时候会失效</strong> vector<int> a{2, 1, 4, 4, 3, 4, 5, 6}; // 剔除4</li></ul><p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = a.<span class="built_in">begin</span>(); it != a.<span class="built_in">end</span>();) &#123;</span><br><span class="line">    <span class="keyword">if</span> (*it == <span class="number">4</span>) &#123;</span><br><span class="line">        it = a.<span class="built_in">erase</span>(it);<span class="comment">// 关联型容器注意迭代器失效</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ++it;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// C++20 才支持 std::erase(a, &#x27;4&#x27;);</span></span><br></pre></td></tr></table></figure> 另：vector扩容时也会导致原迭代器失效</p><ul><li><strong>为什么基类析构函数一般写成虚函数</strong></li></ul><ol style="list-style-type: decimal"><li>不触发多态时，派生类的构造和析构顺序如下</li></ol><ul><li>构造顺序：<ul><li>基类成员对象的构造函数</li><li>基类的构造函数</li><li>派生类成员对象的构造函数</li><li>派生类的构造函数</li></ul></li><li>析构顺序：<ul><li>派生类的析构函数</li><li>派生类成员的析构函数</li><li>基类的析构函数</li><li>基类成员的析构函数</li></ul></li></ul><ol start="2" style="list-style-type: decimal"><li><p>触发多态时（释放基类指针或引用指向的派生类对象时），如果基类的析构函数<strong>非虚函数</strong> 该情况下，基类析构函数则为<strong>静态绑定</strong>，因此派生类析构不会被调用，如果派生类存在内存申请或者有构造类对象则会造成内存泄漏 另：如果派生类并无额外资源需要释放或析构（情况少见），则不要无脑声明基类虚析构，以防编译器生成虚函数表，无意义的扩大类的存储空间</p></li><li><p>触发多态时（释放基类指针或引用指向的派生类对象时），如果基类的析构函数为<strong>虚函数</strong> 该情况下，基类析构函数属于动态绑定，在释放派生类会查询虚函数表指针vfptr指向的是派生类的虚函数表， 则先调用派生类的析构函数，同时<strong>编译器保证</strong>每个派生类的析构函数结束时会自动（隐含地）调上基类的析构函数，而普通虚函数并不会</p></li></ol><ul><li><p><strong>解释下<code>std::move</code></strong> 只是进行了左右值类型转换，一般配合移动构造使用 可移动对象在<strong>需要拷贝且被拷贝者之后不再被需要</strong>的场景，建议使用<code>std::move</code>触发移动语义，提升性能</p></li><li><p><strong>指针和引用的区别</strong></p></li></ul><table><thead><tr class="header"><th align="center">指针</th><th align="center">引用</th></tr></thead><tbody><tr class="odd"><td align="center">指针变量需要占用内存空间</td><td align="center">不占用空间</td></tr><tr class="even"><td align="center">定义和声明可以分开，初始化可以为 nullptr</td><td align="center">只有声明，没有定义，声明时必须初始化，不能为空</td></tr><tr class="odd"><td align="center">可以递增，递减</td><td align="center">不支持加减</td></tr><tr class="even"><td align="center">可以实现多级（例如：指针的指针）</td><td align="center">只支持一级</td></tr><tr class="odd"><td align="center">sizeof指针，为指针变量内的地址值的长度，32位 = 4字节，64位 = 8字节</td><td align="center">sizeof引用，为引用变量类型的长度</td></tr><tr class="even"><td align="center">初始化后可以改变指向</td><td align="center">不能改变引用指向</td></tr></tbody></table><ul><li><p><strong>const int *p和int *const p区别</strong> const int <em>p：const修饰的是*p，即指针变量指向的内存单元的值，即内存值是常量无法改变; int </em>const p: const修饰的是p，即指针变量的值，即指向的内存单元的地址无法改变，即无法改变指针的指向</p></li><li><p>手写string类 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">String</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">String</span>(<span class="keyword">const</span> <span class="keyword">char</span>* cstr) &#123;  <span class="comment">// notice const</span></span><br><span class="line">    <span class="keyword">if</span> (cstr == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      data_ = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1</span>];</span><br><span class="line">      data_[<span class="number">0</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      data_ = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(cstr) + <span class="number">1</span>];</span><br><span class="line">      <span class="built_in">strcpy</span>(data_, cstr);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ~<span class="built_in">String</span>() &#123;</span><br><span class="line">    <span class="keyword">if</span> (data_ != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      <span class="keyword">delete</span>[] data_;</span><br><span class="line">      data_ = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">String</span>(<span class="keyword">const</span> String&amp; str) &#123;</span><br><span class="line">    data_ = <span class="keyword">new</span> <span class="keyword">char</span>[str.<span class="built_in">Size</span>()];</span><br><span class="line">    <span class="built_in">strcpy</span>(data_, str.data_);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  String&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> String&amp; str) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;str) &#123;</span><br><span class="line">      <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span>[] data_;  <span class="comment">// notice delete original</span></span><br><span class="line">    data_ = <span class="keyword">new</span> <span class="keyword">char</span>[str.<span class="built_in">Size</span>()];</span><br><span class="line">    <span class="built_in">strcpy</span>(data_, str.data_);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">String</span>(String&amp;&amp; str) <span class="keyword">noexcept</span> &#123;   <span class="comment">// notice noexcept</span></span><br><span class="line">    data_ = str.data_;</span><br><span class="line">    str.data_ = <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  String&amp; <span class="keyword">operator</span>=(String&amp;&amp; str) <span class="keyword">noexcept</span> &#123;    <span class="comment">// notice noexcept</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;str) &#123;</span><br><span class="line">      <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span>[] data_;  <span class="comment">// notice delete original</span></span><br><span class="line">    data_ = str.data_;</span><br><span class="line">    str.data_ = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">uint32_t</span> <span class="title">Size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">strlen</span>(data_) + <span class="number">1</span>; &#125;  <span class="comment">// notice const</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">char</span>* data_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p></li><li><p>用栈实现队列 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Queue</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">const</span> T&amp; element)</span> </span>&#123;</span><br><span class="line">      back_element = element;</span><br><span class="line">      sta_.<span class="built_in">push</span>(element);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (!stb_.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        stb_.<span class="built_in">pop</span>();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!sta_.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">          <span class="keyword">while</span> (!sta_.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            stb_.<span class="built_in">push</span>(sta_.<span class="built_in">top</span>());</span><br><span class="line">            sta_.<span class="built_in">pop</span>();</span><br><span class="line">          &#125;</span><br><span class="line">          stb_.<span class="built_in">pop</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;queue is empty&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">T <span class="title">front</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (!stb_.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> stb_.<span class="built_in">top</span>();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!sta_.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">          <span class="keyword">while</span> (!sta_.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            stb_.<span class="built_in">push</span>(sta_.<span class="built_in">top</span>());</span><br><span class="line">            sta_.<span class="built_in">pop</span>();</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> stb_.<span class="built_in">top</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;queue is empty&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">T <span class="title">back</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (!<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> back_element;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;queue is empty&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;      <span class="comment">// notice const</span></span><br><span class="line">      <span class="keyword">return</span> sta_.<span class="built_in">size</span>() + stb_.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;    <span class="comment">// notice const</span></span><br><span class="line">      <span class="keyword">return</span> sta_.<span class="built_in">empty</span>() &amp;&amp; stb_.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    std::stack&lt;T&gt; sta_;</span><br><span class="line">    std::stack&lt;T&gt; stb_;</span><br><span class="line">    T back_element;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p></li><li><p>手写智能指针shared_ptr <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SharedPtr</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">SharedPtr</span>() : <span class="built_in">ref_count_</span>(<span class="literal">nullptr</span>), <span class="built_in">ptr_</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">SharedPtr</span><span class="params">(T* p)</span> : ref_count_(new uint32_t(<span class="number">1</span>)), ptr_(p) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">SharedPtr</span>(<span class="keyword">const</span> SharedPtr&amp; sh_p)</span><br><span class="line">      : <span class="built_in">ref_count_</span>(sh_p.ref_count_), <span class="built_in">ptr_</span>(sh_p.ptr_) &#123;</span><br><span class="line">    <span class="keyword">if</span> (ref_count_) &#123;</span><br><span class="line">      ++(*ref_count_);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  SharedPtr&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> SharedPtr&amp; sh_p) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;sh_p) &#123;</span><br><span class="line">      <span class="keyword">if</span> (ref_count_) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((--(*ref_count_)) == <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="built_in">Release</span>();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      ref_count_ = sh_p.ref_count_;</span><br><span class="line">      ptr_ = sh_p.ptr_;</span><br><span class="line">      ++(*ref_count_);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">SharedPtr</span>(SharedPtr&amp;&amp; sh_p) <span class="keyword">noexcept</span></span><br><span class="line">      : <span class="built_in">ref_count_</span>(sh_p.ref_count_), <span class="built_in">ptr_</span>(sh_p.ptr_) &#123;</span><br><span class="line">    sh_p.ref_count_ = <span class="literal">nullptr</span>;</span><br><span class="line">    sh_p.ptr_ = <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  SharedPtr&amp; <span class="keyword">operator</span>=(SharedPtr&amp;&amp; sh_p) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;sh_p) &#123;</span><br><span class="line">      <span class="keyword">if</span> (ref_count_) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((--(*ref_count_)) == <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="built_in">Release</span>();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      ref_count_ = sh_p.ref_count_;</span><br><span class="line">      ptr_ = sh_p.ptr_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  T* <span class="keyword">operator</span>-&gt;() &#123; <span class="keyword">return</span> ptr_; &#125;</span><br><span class="line"></span><br><span class="line">  T&amp; <span class="keyword">operator</span>*() &#123; <span class="keyword">return</span> *ptr_; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">T* <span class="title">get</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> ptr_; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">uint32_t</span> <span class="title">use_count</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> ref_count_ ? *ref_count_ : <span class="number">0</span>; &#125;</span><br><span class="line"></span><br><span class="line">  ~<span class="built_in">SharedPtr</span>() &#123;</span><br><span class="line">    <span class="keyword">if</span> (ref_count_) &#123;</span><br><span class="line">      <span class="keyword">if</span> ((--(*ref_count_)) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">Release</span>();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Release</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ptr_) &#123;</span><br><span class="line">      <span class="keyword">delete</span> ptr_;</span><br><span class="line">      ptr_ = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ref_count_) &#123;</span><br><span class="line">      <span class="keyword">delete</span> ref_count_;</span><br><span class="line">      ref_count_ = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">uint32_t</span>* ref_count_;</span><br><span class="line">  T* ptr_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p></li></ul><h1 id="linux系统知识点">Linux系统知识点</h1><ul><li><strong>Linux线程、进程区别，进程间通信用过哪些</strong> 线程间共享虚拟内存空间，是CPU的最小调度单元 进程各自独占虚拟内存空间，是CPU的最小资源分配单元，一个进程可以拥有多个线程 另：线程和进程在内核中统一使用struct task_struct描述符管理，从内核角度进程和线程统称为task，均使用_do_fork带入不同的flag创建</li></ul>[图1][2]<p align="center">图1 task创建图</p><ul><li><strong>Linux进程间通信用过哪些</strong></li><li>unix域套接字socket，相对网络套接字性能更高</li><li>网络套接字</li><li>message queue</li><li>share mem</li><li>pipe</li><li><p>fifo</p></li><li><p><strong>Linux查看当前系统运行的进程信息的命令</strong> 可以使用top或者ps命令查看 top指令的表头含义 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">PID — 进程id</span><br><span class="line">USER — 进程所有者</span><br><span class="line">PR — 进程优先级</span><br><span class="line">NI — nice值，CFS调度器使用，值越高优先级越低</span><br><span class="line">VIRT — 进程使用的虚拟内存总量，单位kb。VIRT=SWAP+RES</span><br><span class="line">RES — 进程使用的、未被换出的物理内存大小，单位kb，RES=CODE+DATA</span><br><span class="line">SHR — 共享内存大小，单位kb</span><br><span class="line">S —进程状态。D=不可中断的睡眠状态 R=运行 S=睡眠 T=跟踪/停止 Z=僵尸进程</span><br><span class="line"><span class="meta">%</span><span class="bash">CPU — 上次更新到现在的CPU时间占用百分比</span></span><br><span class="line"><span class="meta">%</span><span class="bash">MEM — 进程使用的物理内存百分比</span></span><br><span class="line">TIME+ — 进程使用的CPU时间总计，单位1/100秒</span><br><span class="line">COMMAND — 进程名称（命令名/命令行）</span><br></pre></td></tr></table></figure></p></li><li><p><strong>Linux如何用命令判断文件1.dat中是否含有”abc”字符串</strong> 这里主要是为了考察grep指令，在linux环境下开发，grep指令太重要了，必须掌握 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -nr &quot;abc&quot; 1.dat</span><br></pre></td></tr></table></figure></p></li><li><p><strong>Linux硬盘挂载指令</strong> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">挂载指令：mount</span><br><span class="line">查看系统挂载点：cat /proc/mounts</span><br><span class="line">查看挂载点的使用情况：df -h</span><br><span class="line">查看快设备节点的信息：blkid, lsblk</span><br></pre></td></tr></table></figure></p></li><li><p><strong>Linux如何查看网络连接状况，如何查看系统都开启了哪些端口</strong> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ifconfig, ip</span><br><span class="line">netstat</span><br></pre></td></tr></table></figure></p></li></ul><h1 id="开发经验">开发经验</h1><p>推荐：如何优雅的调试段错误 https://cloud.tencent.com/developer/article/1629269</p><h1 id="面试沟通技巧">面试沟通技巧</h1><ul><li>不要轻易放弃，抗住压力，有时候一些偏难的题目可能只是面试官在探查你的技能掌握深度</li><li>白板题时，积极主动表达自己的思路，方便面试官给予思路的修正和提示</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;正值秋招面试季，梳理了一些常见的面试题。
    
    </summary>
    
      <category term="感悟" scheme="http://jxbuaa.github.io/categories/%E6%84%9F%E6%82%9F/"/>
    
    
      <category term="C++" scheme="http://jxbuaa.github.io/tags/C/"/>
    
      <category term="面试" scheme="http://jxbuaa.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>海思Hi3519 uboot start.s分析</title>
    <link href="http://jxbuaa.github.io/2020/07/%E6%B5%B7%E6%80%9DHi3519%20uboot%20start.s%E5%88%86%E6%9E%90/"/>
    <id>http://jxbuaa.github.io/2020/07/海思Hi3519 uboot start.s分析/</id>
    <published>2020-07-14T02:05:35.000Z</published>
    <updated>2020-07-14T02:58:04.744Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言">前言</h1><p>简单梳理海思Hi3519 uboot start.s一阶段和二阶段的流程图 <span id="more"></span></p><img src="https://wx1.sinaimg.cn/mw690/6a6ccd8fly1ggqb8e61o9j20jo1333yz.jpg" alt="图1" /><p align="center">start.s流程分析</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;简单梳理海思Hi3519 uboot start.s一阶段和二阶段的流程图
    
    </summary>
    
      <category term="技术" scheme="http://jxbuaa.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Driver" scheme="http://jxbuaa.github.io/tags/Driver/"/>
    
      <category term="Linux" scheme="http://jxbuaa.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Python保存.mht格式网页</title>
    <link href="http://jxbuaa.github.io/2019/01/Python%E4%BF%9D%E5%AD%98.mht%E6%A0%BC%E5%BC%8F%E7%BD%91%E9%A1%B5/"/>
    <id>http://jxbuaa.github.io/2019/01/Python保存.mht格式网页/</id>
    <published>2019-01-29T14:59:47.000Z</published>
    <updated>2019-01-29T15:26:04.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言">前言</h1><p>自动化完成目标网页的保存，文件名为标题名，网页可离线打开，并保证不缺损信息。 <span id="more"></span> # 实现方案 使用善于爬网页的python实现 方式1：urllib保存html urllib是一个包含request、error、parse、robotparser四个模块，关乎网络资源请求的包 调用urllib完成版本1 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib.request </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getHtml</span>(<span class="params">url</span>):</span></span><br><span class="line">headers = &#123;<span class="string">&quot;User-Agent&quot;</span>: <span class="string">&quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/59.0.3071.115 Safari/537.36&quot;</span>&#125;</span><br><span class="line">request = urllib.request.Request(url, headers=headers)</span><br><span class="line">response = urllib.request.urlopen(request).read()</span><br><span class="line"><span class="keyword">return</span> response</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">saveHtml</span>(<span class="params">file_name, file_content</span>):</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(file_name.replace(<span class="string">&#x27;/&#x27;</span>, <span class="string">&#x27;_&#x27;</span>) + <span class="string">&quot;.html&quot;</span>, <span class="string">&quot;wb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">f.write(file_content)</span><br><span class="line"></span><br><span class="line">base_url = <span class="string">&#x27;http://www.weain.mil.cn/cggg/zbgg/&#x27;</span></span><br><span class="line">base_path = <span class="string">&#x27;E:\\jkl\\&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> p <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">615675</span>, <span class="number">615682</span>):</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">result = getHtml(base_url + <span class="built_in">str</span>(p) + <span class="string">&#x27;.html&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(base_url + <span class="built_in">str</span>(p) + <span class="string">&#x27;.html&#x27;</span>)</span><br><span class="line">path = base_path + <span class="built_in">str</span>(p)</span><br><span class="line"><span class="comment">#print(path)</span></span><br><span class="line">saveHtml(path, result)</span><br><span class="line">p = p+<span class="number">1</span></span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;done&quot;</span>)</span><br></pre></td></tr></table></figure></p><p>问题 1.1 反爬 该网站虽然简单，web服务应该还是添加了基本的反爬措施 解决：需要在request时添加浏览器headers，将程序行为掩饰为浏览器行为</p><p>1.2 html信息不全 抓下来html文件信息不全，图片损失，网页框架混乱 该方式只适合快速抓取关键字的场景</p><p>方式2：Chilkat保存MHTML(mht) MHTML = MIME Encapsulation of Aggregate HTML Documents 将一个多附件网页(图片、flash、Java小程序)存储为单一文档，可用于发送html电子邮件</p><p>Chilkat是一个功能强大的有直接提供保存mht格式文件接口的包 调用Chilkat完成版本2 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># !/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*-coding:utf-8-*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> chilkat</span><br><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_title</span>(<span class="params">url</span>):</span></span><br><span class="line">    headers = &#123;<span class="string">&quot;User-Agent&quot;</span>: <span class="string">&quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/59.0.3071.115 Safari/537.36&quot;</span>&#125;</span><br><span class="line">    request = urllib.request.Request(url, headers=headers)</span><br><span class="line">    html = urllib.request.urlopen(request).read()</span><br><span class="line">    soup = BeautifulSoup(html, <span class="string">&#x27;lxml&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(soup.find(<span class="string">&#x27;h1&#x27;</span>).get_text())</span><br><span class="line">    <span class="keyword">return</span> soup.find(<span class="string">&#x27;h1&#x27;</span>).get_text()</span><br><span class="line"></span><br><span class="line">mht = chilkat.CkMht()</span><br><span class="line"></span><br><span class="line">success = mht.UnlockComponent(<span class="string">&quot;Anything for 30-day trial&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> (success != <span class="literal">True</span>):</span><br><span class="line">    <span class="built_in">print</span>(mht.lastErrorText())</span><br><span class="line">    sys.exit()</span><br><span class="line"></span><br><span class="line">base_url = <span class="string">&quot;http://www.weain.mil.cn/cggg/zbgg/&quot;</span></span><br><span class="line">base_path = <span class="string">&quot;C:\\Users\\x.x-pc\\Desktop\\html_grep\\save\\&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    print(&quot;Please Input Web Page Index: &quot;)</span></span><br><span class="line"><span class="string">    start = input(&quot;please input web page index: &quot;)</span></span><br><span class="line"><span class="string">    print(&quot;start &gt;&gt; &quot; + start)</span></span><br><span class="line"><span class="string">    print(&quot;end   &gt;&gt; &quot; + end)</span></span><br><span class="line"><span class="string">    print(start + &quot;  &quot; + end);</span></span><br><span class="line"><span class="string">    sys.exit()</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">615675</span>, <span class="number">615676</span>):</span><br><span class="line">    <span class="comment">#   try:</span></span><br><span class="line">            target_url = base_url + <span class="built_in">str</span>(p) + <span class="string">&#x27;.html&#x27;</span></span><br><span class="line">            save_path = base_path + get_title(target_url) + <span class="string">&#x27;.mht&#x27;</span></span><br><span class="line">            <span class="built_in">print</span>(target_url)</span><br><span class="line">            <span class="built_in">print</span>(save_path)</span><br><span class="line"></span><br><span class="line">            success = mht.GetAndSaveMHT(target_url, save_path)</span><br><span class="line">            <span class="keyword">if</span> (success != <span class="literal">True</span>):</span><br><span class="line">                <span class="built_in">print</span>(mht.lastErrorText())</span><br><span class="line">                sys.exit()</span><br><span class="line"></span><br><span class="line">            p = p + <span class="number">1</span></span><br><span class="line">    <span class="comment">#    except:</span></span><br><span class="line">    <span class="comment">#        print(&quot;Exception&quot;);</span></span><br><span class="line">    <span class="comment">#        continue</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;done&quot;</span>)</span><br></pre></td></tr></table></figure></p><p>问题： 2.1 该方式可以较好的解决问题1.2，但是依然有部分图片信息缺损 与chrome浏览器直接右键保存为mht格式文件信息差距较大</p><p>2.2 该网页采用的是动态加载的方式，发布的采购公告信息使用Javascript加载 Chilkat只能抓取到当前页面，无法抓到动态页面 接下来就是想办法抓到动态页面，然后拼接到静态页面 emmm ……</p><p>方式3：Selenium Selenium是一个用于Web应用程序测试工具 Selenium测试直接运行在浏览器中，就像真正的用户在操作一样 支持的浏览器包括IE（7, 8, 9, 10, 11），Mozilla Firefox，Safari，Google Chrome，Opera等。 同时python支持对应的selenium包 selenium直接与chromedriver进行交互，调用chromedriver原生api实现浏览器的操作 可以利用浏览器保存完整的mht文件</p><p>问题： 保存网页时默认获取的是html的title字段，导致每个网页该字段都一样 真正的标题则在h1字段，需要修改windows保存窗口的命名栏 而操作windows窗口则超过了selenium的能力范畴</p><p>为了解决该问题，先后搜查了如下方式： AutoHotKey、AutoIt 其中AutoHotKey是一款免费的、Windows平台下开放源代码的热键脚本语言 可以通过脚本调用键鼠、系统接口及程序，并创建基于简单语言的图形化界面的执行程序</p><p>该工具非常强大，可以自动化完成高重复性操作，可适用于自动化测试、生产中</p><p>AutoHotKey可将该语言脚本例化成exe，供python调用 AutoIt则有对应的pyautoit包，最终实现也是调用AutoItX3.dll</p><p>pyautogui包可以操作键鼠，不需要调用其他动态库，且使用相对简单，为该问题最后选取的方案 为了提高人机交互，使用tkinter实现了简单的对话框界面。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> tkinter.messagebox</span><br><span class="line"><span class="keyword">from</span> tkinter <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> tkinter.filedialog <span class="keyword">import</span> askdirectory</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> pyautogui</span><br><span class="line"><span class="keyword">import</span> pyperclip</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.chrome.service <span class="keyword">import</span> Service</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">init_driver</span>(<span class="params">path, quiet=<span class="literal">True</span></span>):</span></span><br><span class="line">    service = Service(executable_path=path)</span><br><span class="line">    <span class="comment"># service.command_line_args()</span></span><br><span class="line">    service.start()</span><br><span class="line"></span><br><span class="line">    custom_options = webdriver.ChromeOptions()</span><br><span class="line">    custom_options.add_argument(<span class="string">&quot;--save-page-as-mhtml&quot;</span>)</span><br><span class="line">    custom_options.add_argument(<span class="string">&quot;--start-maximized&quot;</span>)</span><br><span class="line">    custom_options.add_argument(<span class="string">&#x27;--disable-infobars&#x27;</span>)</span><br><span class="line">    custom_options.add_argument(<span class="string">&#x27;--ignore-certificate-errors&#x27;</span>)</span><br><span class="line">    custom_options.add_argument(<span class="string">&#x27;--ignore-ssl-errors&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> quiet:</span><br><span class="line">        <span class="comment"># 静默</span></span><br><span class="line">        custom_options.add_argument(<span class="string">&#x27;--headless&#x27;</span>)</span><br><span class="line">        custom_options.add_argument(<span class="string">&#x27;--disable-gpu&#x27;</span>)</span><br><span class="line">        custom_options.add_argument(<span class="string">&quot;--hide-scrollbars&quot;</span>)</span><br><span class="line"></span><br><span class="line">    driver = webdriver.Chrome(executable_path=path, options=custom_options)</span><br><span class="line">    <span class="keyword">return</span> service, driver</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exit_driver</span>(<span class="params">service, driver</span>):</span></span><br><span class="line">    driver.quit()</span><br><span class="line">    service.stop()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">save_page_as</span>(<span class="params">name</span>):</span></span><br><span class="line">    <span class="comment"># 保存</span></span><br><span class="line">    pyautogui.hotkey(<span class="string">&#x27;ctrl&#x27;</span>, <span class="string">&#x27;s&#x27;</span>)</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="comment"># pyautogui不支持中文</span></span><br><span class="line">    pyperclip.copy(name)</span><br><span class="line">    pyautogui.hotkey(<span class="string">&#x27;ctrl&#x27;</span>, <span class="string">&#x27;v&#x27;</span>)</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    pyautogui.hotkey(<span class="string">&#x27;enter&#x27;</span>)</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="comment"># 暂不支持文件已存在（覆盖保存）</span></span><br><span class="line">    <span class="comment"># pyautogui.hotkey(&#x27;y&#x27;)</span></span><br><span class="line">    <span class="comment"># time.sleep(3)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">save_mht</span>(<span class="params">driver_path, tgt_url_list, file_path_list</span>):</span></span><br><span class="line">    service, driver = init_driver(driver_path, quiet=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># end_cnt = 1</span></span><br><span class="line">    opened_chrome_tab_cnt = <span class="number">0</span></span><br><span class="line">    allowed_chrome_tab_cnt = <span class="number">5</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">        <span class="comment"># print(&quot;len(tgt_url_list)&quot; + str(i) + &quot; = &quot; + str(len(tgt_url_list[i])))</span></span><br><span class="line">        <span class="built_in">print</span>(file_path_list[i])</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(tgt_url_list[i]) != <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">for</span> url <span class="keyword">in</span> tgt_url_list[i]:</span><br><span class="line">                driver.get(url)</span><br><span class="line">                opened_chrome_tab_cnt += <span class="number">1</span></span><br><span class="line">                title = driver.find_element_by_tag_name(<span class="string">&#x27;h1&#x27;</span>)</span><br><span class="line">                <span class="built_in">print</span>(title.text)</span><br><span class="line">                save_page_as(file_path_list[i] + <span class="string">&quot;\\&quot;</span> + title.text)</span><br><span class="line">                <span class="comment"># # 避免结束多开1个新标签页</span></span><br><span class="line">                <span class="comment"># if end_cnt == len(tgt_url_list[i]):</span></span><br><span class="line">                <span class="comment">#     break</span></span><br><span class="line">                <span class="comment"># else:</span></span><br><span class="line">                <span class="comment">#     end_cnt += 1</span></span><br><span class="line">                <span class="comment"># 打开新标签页</span></span><br><span class="line">                pyautogui.hotkey(<span class="string">&#x27;ctrl&#x27;</span>, <span class="string">&#x27;t&#x27;</span>)</span><br><span class="line">                driver.switch_to.window(driver.window_handles[-<span class="number">1</span>])</span><br><span class="line">                <span class="comment"># 暂时规避chrome无法修改搜索引擎导致新标签页阻塞连接的问题</span></span><br><span class="line">                pyperclip.copy(url)</span><br><span class="line">                pyautogui.hotkey(<span class="string">&#x27;ctrl&#x27;</span>, <span class="string">&#x27;v&#x27;</span>)</span><br><span class="line">                pyautogui.hotkey(<span class="string">&#x27;enter&#x27;</span>)</span><br><span class="line"></span><br><span class="line">                <span class="comment"># 处理已开标签避免chrome标签过多将内存耗尽</span></span><br><span class="line">                <span class="keyword">if</span> opened_chrome_tab_cnt == allowed_chrome_tab_cnt:</span><br><span class="line">                    handle = driver.current_window_handle</span><br><span class="line">                    <span class="keyword">while</span> opened_chrome_tab_cnt != <span class="number">0</span>:</span><br><span class="line">                        driver.switch_to.window(driver.window_handles[<span class="number">0</span>])</span><br><span class="line">                        driver.close()</span><br><span class="line">                        opened_chrome_tab_cnt -= <span class="number">1</span></span><br><span class="line">                        time.sleep(<span class="number">2</span>)</span><br><span class="line">                    driver.switch_to.window(handle)</span><br><span class="line"></span><br><span class="line">    time.sleep(<span class="number">6</span>)</span><br><span class="line">    exit_driver(service, driver)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_tgt_url</span>(<span class="params">driver_path, start_index_list, start_item_list, item_total_cnt_list</span>):</span></span><br><span class="line">    service, driver = init_driver(driver_path)</span><br><span class="line">    item_per_page_cnt = <span class="number">8</span></span><br><span class="line">    index_page_cnt_list = [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">    tgt_url_list = [[] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>)]</span><br><span class="line">    home_page_url = <span class="string">&quot;http://www.weain.mil.cn&quot;</span></span><br><span class="line">    index_page_id_list = [<span class="string">&quot;/cggg/zbgg/&quot;</span>, <span class="string">&quot;/cggg/zbgg1/&quot;</span>, <span class="string">&quot;/cggg/gzgg/&quot;</span>, <span class="string">&quot;/cggg/qtgg/&quot;</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">        <span class="keyword">if</span> item_total_cnt_list[i] != <span class="string">&quot;&quot;</span>:</span><br><span class="line">            <span class="comment"># 向上取整</span></span><br><span class="line">            index_page_cnt_list[i] = math.ceil((<span class="built_in">int</span>(start_item_list[i]) + <span class="built_in">int</span>(item_total_cnt_list[i]) - <span class="number">1</span>) / item_per_page_cnt)</span><br><span class="line">            <span class="comment"># print(index_page_cnt_list[i])</span></span><br><span class="line"></span><br><span class="line">            href_cnt = <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> page_index <span class="keyword">in</span> <span class="built_in">range</span>(index_page_cnt_list[i]):</span><br><span class="line">                <span class="comment"># 获取索引页地址</span></span><br><span class="line">                <span class="keyword">if</span> start_index_list[i] == <span class="string">&quot;1&quot;</span> <span class="keyword">and</span> page_index == <span class="number">0</span>:</span><br><span class="line">                    index_page_url = home_page_url + index_page_id_list[i] + <span class="string">&quot;index.html&quot;</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    index_page_url = home_page_url + index_page_id_list[i] + \</span><br><span class="line">                                     <span class="string">&quot;index_&quot;</span> + <span class="built_in">str</span>(<span class="built_in">int</span>(start_index_list[i]) + page_index) + <span class="string">&quot;.html&quot;</span></span><br><span class="line"></span><br><span class="line">                <span class="built_in">print</span>(index_page_url)</span><br><span class="line">                <span class="comment"># 索引页内获取tgt_url</span></span><br><span class="line">                driver.get(index_page_url)</span><br><span class="line">                html = driver.page_source</span><br><span class="line">                soup = BeautifulSoup(html, <span class="string">&quot;html.parser&quot;</span>)</span><br><span class="line">                href_list = soup.find_all(href=re.<span class="built_in">compile</span>(<span class="string">&quot;^&quot;</span> + index_page_id_list[i]), target=<span class="literal">True</span>, title=<span class="literal">True</span>)</span><br><span class="line">                <span class="comment"># print(href_list)</span></span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> href_list:</span><br><span class="line">                    <span class="comment"># print(j)</span></span><br><span class="line">                    <span class="comment"># print(home_page_url + j[&#x27;href&#x27;])</span></span><br><span class="line">                    <span class="keyword">if</span> href_cnt != <span class="built_in">int</span>(start_item_list[i]):</span><br><span class="line">                        href_cnt += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        <span class="built_in">print</span>(home_page_url + j[<span class="string">&#x27;href&#x27;</span>])</span><br><span class="line">                        tgt_url_list[i].append(home_page_url + j[<span class="string">&#x27;href&#x27;</span>])</span><br><span class="line">                        <span class="comment"># print(str(len(tgt_url_list[i])) + &quot; -- &quot; + item_total_cnt_list[i])</span></span><br><span class="line">                        <span class="keyword">if</span> <span class="built_in">len</span>(tgt_url_list[i]) == <span class="built_in">int</span>(item_total_cnt_list[i]):</span><br><span class="line">                            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    exit_driver(service, driver)</span><br><span class="line">    <span class="comment"># print(tgt_url_list)</span></span><br><span class="line">    <span class="keyword">return</span> tgt_url_list</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">center_window</span>(<span class="params">root, width, height</span>):</span></span><br><span class="line">    screenwidth = root.winfo_screenwidth()</span><br><span class="line">    screenheight = root.winfo_screenheight()</span><br><span class="line">    size = <span class="string">&#x27;%dx%d+%d+%d&#x27;</span> % (width, height, (screenwidth - width) / <span class="number">2</span>, (screenheight - height) / <span class="number">2</span>)</span><br><span class="line">    <span class="comment"># print(size)</span></span><br><span class="line">    root.geometry(size)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main_process</span>(<span class="params">cb_name_list, start_index_list, start_item_list, item_total_cnt_list, file_save_path</span>):</span></span><br><span class="line">    <span class="comment"># 获取当前路径（简化部署默认chromedriver在同一路径）</span></span><br><span class="line">    pwd = os.path.split(os.path.realpath(__file__))[<span class="number">0</span>]</span><br><span class="line">    chrome_driver_path = pwd + <span class="string">&quot;\\chromedriver.exe&quot;</span></span><br><span class="line">    <span class="comment"># print(chrome_driver_path)</span></span><br><span class="line">    <span class="comment"># 检查chromedriver是否存在</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(chrome_driver_path):</span><br><span class="line">        <span class="comment"># raise Exception(&quot;chromedriver必须与exe同一路径!&quot;)</span></span><br><span class="line">        tkinter.messagebox.showerror(<span class="string">&quot;错误&quot;</span>, <span class="string">&quot;chromedriver必须与exe同一路径&quot;</span>)</span><br><span class="line">        exit(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 获得当前系统时间创建文件夹以规避文件覆盖问题</span></span><br><span class="line">    localtime = time.strftime(<span class="string">&#x27;%Y-%m-%d_%H-%M-%S&#x27;</span>, time.localtime(time.time()))</span><br><span class="line">    file_save_path = file_save_path + <span class="string">&quot;\\&quot;</span> + localtime</span><br><span class="line">    <span class="comment"># print(file_save_path)</span></span><br><span class="line">    os.mkdir(file_save_path)</span><br><span class="line"></span><br><span class="line">    file_save_path_list = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">        file_save_path_list.append(file_save_path + <span class="string">&quot;\\&quot;</span> + cb_name_list[i])</span><br><span class="line">        <span class="keyword">if</span> item_total_cnt_list[i] != <span class="string">&quot;&quot;</span>:</span><br><span class="line">            os.mkdir(file_save_path_list[i])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 静默获取target_url</span></span><br><span class="line">    target_url_list = get_tgt_url(chrome_driver_path, start_index_list, start_item_list, item_total_cnt_list)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 保存target_url</span></span><br><span class="line">    save_mht(chrome_driver_path, target_url_list, file_save_path_list)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    root = Tk()</span><br><span class="line">    root.title(<span class="string">&quot;保存MHT&quot;</span>)</span><br><span class="line">    root.resizable(width=<span class="literal">False</span>, height=<span class="literal">False</span>)</span><br><span class="line">    center_window(root, <span class="number">550</span>, <span class="number">400</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">select_path</span>():</span></span><br><span class="line">        path_ = askdirectory()</span><br><span class="line">        save_path_text.<span class="built_in">set</span>(path_.replace(<span class="string">&quot;/&quot;</span>, <span class="string">&quot;\\&quot;</span>))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">check</span>():</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">            <span class="keyword">if</span> cb_var_list[i].get() == <span class="string">&#x27;0&#x27;</span>:</span><br><span class="line">                entry_item_cnt_list[i].delete(<span class="number">0</span>, END)</span><br><span class="line"></span><br><span class="line">    entry_start_index_list = []</span><br><span class="line">    entry_start_item_list = []</span><br><span class="line">    entry_item_cnt_list = []</span><br><span class="line">    cb_name_list = [<span class="string">&quot;招标公告&quot;</span>, <span class="string">&quot;中标公告&quot;</span>, <span class="string">&quot;更正公告&quot;</span>, <span class="string">&quot;其他公告&quot;</span>]</span><br><span class="line">    cb_var_list = [StringVar() <span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>)]</span><br><span class="line">    start_index_text_list = [StringVar() <span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>)]</span><br><span class="line">    start_item_text_list = [StringVar() <span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>)]</span><br><span class="line">    item_cnt_text_list = [StringVar() <span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>)]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">        frame = Frame(root)</span><br><span class="line">        cb_var_list[i].<span class="built_in">set</span>(<span class="number">0</span>)</span><br><span class="line">        Checkbutton(frame, text=cb_name_list[i], variable=cb_var_list[i], command=check).grid(row=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        Label(frame, text=<span class="string">&quot;起始索引页:&quot;</span>).grid(row=<span class="number">1</span>, column=<span class="number">0</span>)</span><br><span class="line">        start_index_text_list[i].<span class="built_in">set</span>(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">        entry_start_index_list.append(Entry(frame, textvariable=start_index_text_list[i], width=<span class="number">10</span>))</span><br><span class="line">        entry_start_index_list[i].grid(row=<span class="number">1</span>, column=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        Label(frame, text=<span class="string">&quot;起始条目:&quot;</span>).grid(row=<span class="number">1</span>, column=<span class="number">2</span>, padx=<span class="number">20</span>)</span><br><span class="line">        start_item_text_list[i].<span class="built_in">set</span>(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">        entry_start_item_list.append(Entry(frame, textvariable=start_item_text_list[i], width=<span class="number">10</span>))</span><br><span class="line">        entry_start_item_list[i].grid(row=<span class="number">1</span>, column=<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">        Label(frame, text=<span class="string">&quot;保存条目数:&quot;</span>).grid(row=<span class="number">1</span>, column=<span class="number">4</span>, padx=<span class="number">20</span>)</span><br><span class="line">        entry_item_cnt_list.append(Entry(frame, textvariable=item_cnt_text_list[i], width=<span class="number">10</span>))</span><br><span class="line">        entry_item_cnt_list[i].grid(row=<span class="number">1</span>, column=<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">        frame.place(x=<span class="number">0</span>, y=i*<span class="number">70</span>)</span><br><span class="line"></span><br><span class="line">    save_path_text = StringVar()</span><br><span class="line"></span><br><span class="line">    frame = Frame(root)</span><br><span class="line">    Label(frame, text=<span class="string">&quot; 保存路径:    &quot;</span>).grid(row=<span class="number">0</span>)</span><br><span class="line">    Entry(frame, textvariable=save_path_text, width=<span class="number">60</span>).grid(row=<span class="number">0</span>, column=<span class="number">1</span>)</span><br><span class="line">    Button(frame, text=<span class="string">&quot;...&quot;</span>, width=<span class="number">1</span>, command=select_path).grid(row=<span class="number">0</span>, column=<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_content</span>():</span></span><br><span class="line">        start_index_list = []</span><br><span class="line">        start_item_list = []</span><br><span class="line">        item_total_cnt_list = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">            start_index_list.append(start_index_text_list[i].get())</span><br><span class="line">            start_item_list.append(start_item_text_list[i].get())</span><br><span class="line">            item_total_cnt_list.append(item_cnt_text_list[i].get())</span><br><span class="line"></span><br><span class="line">        <span class="comment">#检查entry</span></span><br><span class="line">        warning_flag = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">int</span>(start_item_list[i]) &gt; <span class="number">8</span>:</span><br><span class="line">                warning_flag = <span class="literal">True</span></span><br><span class="line">                tkinter.messagebox.showwarning(<span class="string">&quot;警告&quot;</span>, <span class="string">&quot;起始条目不能超过8&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">            <span class="keyword">if</span> cb_var_list[i].get() == <span class="string">&#x27;1&#x27;</span> <span class="keyword">and</span> item_total_cnt_list[i] == <span class="string">&#x27;&#x27;</span>:</span><br><span class="line">                warning_flag = <span class="literal">True</span></span><br><span class="line">                tkinter.messagebox.showwarning(<span class="string">&quot;警告&quot;</span>, <span class="string">&quot;请填入 [&quot;</span> + cb_name_list[i] + <span class="string">&quot;] 保存条目数&quot;</span>)</span><br><span class="line">            <span class="keyword">if</span> cb_var_list[i].get() == <span class="string">&#x27;0&#x27;</span> <span class="keyword">and</span> item_total_cnt_list[i] != <span class="string">&#x27;&#x27;</span>:</span><br><span class="line">                warning_flag = <span class="literal">True</span></span><br><span class="line">                tkinter.messagebox.showwarning(<span class="string">&quot;警告&quot;</span>, <span class="string">&quot;请勾选 [&quot;</span> + cb_name_list[i] + <span class="string">&quot;] &quot;</span>)</span><br><span class="line"></span><br><span class="line">        check_nothing_cnt = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">            <span class="keyword">if</span> cb_var_list[i].get() == <span class="string">&#x27;0&#x27;</span> <span class="keyword">and</span> item_total_cnt_list[i] == <span class="string">&#x27;&#x27;</span>:</span><br><span class="line">                check_nothing_cnt += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> check_nothing_cnt == <span class="number">4</span>:</span><br><span class="line">            warning_flag = <span class="literal">True</span></span><br><span class="line">            tkinter.messagebox.showwarning(<span class="string">&quot;警告&quot;</span>, <span class="string">&quot;请填入‘保存条目数’&quot;</span>)</span><br><span class="line"></span><br><span class="line">        file_save_path = save_path_text.get()</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> file_save_path:</span><br><span class="line">            warning_flag = <span class="literal">True</span></span><br><span class="line">            tkinter.messagebox.showwarning(<span class="string">&quot;警告&quot;</span>, <span class="string">&quot;请选择‘保存路径’&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> warning_flag:</span><br><span class="line">            <span class="comment"># print(item_total_cnt)</span></span><br><span class="line">            <span class="comment"># print(file_save_path)</span></span><br><span class="line">            <span class="comment"># 隐藏主窗口及后续message主窗口</span></span><br><span class="line">            root.withdraw()</span><br><span class="line">            main_process(cb_name_list, start_index_list, start_item_list, item_total_cnt_list, file_save_path)</span><br><span class="line">            tkinter.messagebox.showinfo(<span class="string">&quot;保存MHT&quot;</span>, <span class="string">&quot;完成&quot;</span>)</span><br><span class="line">            root.destroy()</span><br><span class="line">            exit(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    Button(frame, text=<span class="string">&quot;确定&quot;</span>, width=<span class="number">8</span>, command=get_content).grid(row=<span class="number">1</span>, column=<span class="number">1</span>, pady=<span class="number">20</span>)</span><br><span class="line">    frame.place(x=<span class="number">0</span>, y=<span class="number">300</span>)</span><br><span class="line"></span><br><span class="line">    root.mainloop()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;自动化完成目标网页的保存，文件名为标题名，网页可离线打开，并保证不缺损信息。
    
    </summary>
    
      <category term="技术" scheme="http://jxbuaa.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Python" scheme="http://jxbuaa.github.io/tags/Python/"/>
    
      <category term="Selenium" scheme="http://jxbuaa.github.io/tags/Selenium/"/>
    
      <category term="爬虫" scheme="http://jxbuaa.github.io/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>Android 5.1设备驱动调试记录</title>
    <link href="http://jxbuaa.github.io/2019/01/Android%205.1%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E8%B0%83%E8%AF%95%E8%AE%B0%E5%BD%95/"/>
    <id>http://jxbuaa.github.io/2019/01/Android 5.1设备驱动调试记录/</id>
    <published>2019-01-28T14:09:21.000Z</published>
    <updated>2019-01-28T14:56:04.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言">前言</h1><p>简要记录了Android5.1设备驱动的调试记录，以led为例，记录了HAL、Framework层的处理，并对调用关系进行了简要分析。 <span id="more"></span> # HAL Layer 1.g6818_lollipop_v51&gt; 创建led.h头文件</p><p>2.Z:6818171606818_lollipop_v51&gt; 创建led文件夹 &gt; led.c &gt; Android.mk</p><p>3.编译 &gt; source build/envsetup.sh &gt; lunch 选择 21. g6818-userdebug &gt; mmm hardware/libhardware/modules/led/ &gt; ll out/target/product/g6818/system/lib/hw/</p><h1 id="frameworks-layer">Frameworks Layer</h1><p>1.创建JNI接口 　　1.1 创建frameworks/base/services/core/jni/com_android_server_LedService.cpp 　　1.2 修改frameworks/base/services/core/jni/onload.cpp添加注册native接口 　　1.3 修改frameworks/base/services/core/jni/Android.mk 　　添加&quot;com_android_server_LedService.cpp&quot;项</p><blockquote><p>注意： LedService.java的java接口的入参、返回值类型一定要与com_android_server_LedService.cpp的native函数一致 否则，main.txt日志会报注册JNI接口失败&quot;Failed to register native method&quot; 导致zygote初始化失败，反复init</p></blockquote><p>2.创建frameworks/base/services/core/java/com/android/server/LedService.java 实现服务类 修改frameworks/base/services/java/com/android/server/SystemServer.java 注册Led服务到Service Manager中</p><p>3.生成ILedService.java服务接口类 　　3.1 创建frameworks/base/core/java/android/os/ILedService.aidl 　　3.2 修改frameworks/base/Android.mk 　　　　添加编译项&quot;core/java/android/os/ILedService.aidl&quot; 　　3.3 编译 　　mmm frameworks/base/</p><p>4.编译mmm frameworks/base/services/ ll out/target/product/g6818/system/lib/libandroid_servers.so</p><h1 id="框架分析">框架分析</h1><p>调用关系（自顶向下）： &gt; 1.应用Activity private ILedService iLedService = ILedService.Stub.asInterface(ServiceManager.getService(&quot;led&quot;)) Client进程通过ServiceManager(Binder，Stub)向Server进程请求已注册的Led服务 2.iLedService.LedOpen()调用JNI接口，JNI转C++接口 3.C++接口通过int hw_get_module(const char *id, const struct hw_module_t **module) 加载HAL动态库led.default.so dlsym()获取动态库led.default.so中HAL_MODULE_INFO_SYM符号表的入口地址 即struct led_module_t的地址 4.通过句柄直接调用驱动api接口-&gt;内核驱动</p><p>具体实现（自底向上）：<br />&gt; 1.HAL层实现Led.c，直接和内核交互 2.为对接Framework和HAL层，通过JNI机制，创建com_android_server_LedService.cpp实现JNI native接口 3.创建LedService.java 实现服务类，修改SystemServer.java 注册Led服务到Service Manager中 　该类中声明了native_LedOpen()，native_LedOn()，native_LedOff()向下对接JNI native接口 4.创建ILedService.aidl（Android Interface Definition Language）文件，编译生成ILedService.java接口类 　APP进程依靠Binder机制，通过已注册的服务名称，获取该接口类</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;简要记录了Android5.1设备驱动的调试记录，以led为例，记录了HAL、Framework层的处理，并对调用关系进行了简要分析。
    
    </summary>
    
      <category term="技术" scheme="http://jxbuaa.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Android" scheme="http://jxbuaa.github.io/tags/Android/"/>
    
      <category term="Driver" scheme="http://jxbuaa.github.io/tags/Driver/"/>
    
  </entry>
  
  <entry>
    <title>READONLY文件系统配置</title>
    <link href="http://jxbuaa.github.io/2019/01/READONLY%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E9%85%8D%E7%BD%AE/"/>
    <id>http://jxbuaa.github.io/2019/01/READONLY文件系统配置/</id>
    <published>2019-01-28T14:04:40.000Z</published>
    <updated>2019-01-29T15:25:52.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言">前言</h1><p>系统是运行在内存中的，硬盘只是系统运行中的存储媒介。当硬盘对应到内存的数据发生改变时，就需要系统将内存的数据同步更新到硬盘进行存储。 异常掉电之所以具备破坏力，是因为异常掉电会不可预知的中断系统将内存数据回写到硬盘的过程，直接导致文件系统数据紊乱。绝大多数带有日志的文件系统（ext3，ext4，xfs等），大多数情况可以依靠文件系统日志自恢复或者依靠fsck命令恢复，问题是并不是所有损坏都可以被修复。 因此，将整个系统设置为只读模式，防止整个回写过程的发生就成了整个方案的出发点。 <span id="more"></span></p><h1 id="case1-方案实施">Case1-方案实施</h1><blockquote><p>系统环境 Linux发行版操作系统Red Hat Enterprise Linux 6.4 64位</p></blockquote><p>在Red Hat Enterprise Linux 6.4系统中已经集成了READONLY的配置能力。整个配置过程主要涉及到3个系统配置文件。 &gt; /etc/sysconfig/readonly-root</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Set to <span class="string">&#x27;yes&#x27;</span> to mount the system filesystems read-only.</span></span><br><span class="line">READONLY=yes</span><br><span class="line"><span class="meta">#</span><span class="bash"> Set to <span class="string">&#x27;yes&#x27;</span> to mount various temporary state as either tmpfs</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> or on the block device labelled RW_LABEL. Implied by READONLY</span></span><br><span class="line">TEMPORARY_STATE=yes</span><br><span class="line"><span class="meta">#</span><span class="bash"> Place to put a tmpfs <span class="keyword">for</span> temporary scratch writable space</span></span><br><span class="line">RW_MOUNT=/var/lib/stateless/writable</span><br><span class="line"><span class="meta">#</span><span class="bash"> Label on <span class="built_in">local</span> filesystem <span class="built_in">which</span> can be used <span class="keyword">for</span> temporary scratch space</span></span><br><span class="line">RW_LABEL=stateless-rw</span><br><span class="line"><span class="meta">#</span><span class="bash"> Options to use <span class="keyword">for</span> temporary mount</span></span><br><span class="line">RW_OPTIONS=</span><br><span class="line"><span class="meta">#</span><span class="bash"> Label <span class="keyword">for</span> partition with persistent data</span></span><br><span class="line">STATE_LABEL=stateless-state</span><br><span class="line"><span class="meta">#</span><span class="bash"> Where to mount to the persistent data</span></span><br><span class="line">STATE_MOUNT=/var/lib/stateless/state</span><br><span class="line"><span class="meta">#</span><span class="bash"> Options to use <span class="keyword">for</span> peristent mount</span></span><br><span class="line">STATE_OPTIONS=</span><br></pre></td></tr></table></figure><ol style="list-style-type: lower-alpha"><li>READONLY=yes表示将文件系统挂载为只读模式;</li><li>TEMPORARY_STATE=yes表示将系统启动过程中存放临时的状态的路径挂载为tmpfs(内存文件系统，掉电丢失)，或者挂载到被标记为RW_LABEL的块设备。 系统在启动过程需要实时更新一部分系统文件，例如/var/log/messages（记录系统启动日志的文件），这个关键字的作用是保证这部分文件的属性为可读写；</li><li>RW_MOUNT是可读写文件的挂载路径，即/var/lib/stateless/writable下文件具备可读写属性；</li><li>RW_LABEL是可读写的标识；</li><li>对应的有不需要发生变化的“persistent data”，可以用STATE的关键字表示，这里方案并没有到，不做说明。</li></ol><blockquote><p>/etc/rwtab</p></blockquote><p>这个配置文件记录了，当系统被设置为只读时，被排除在外依然可读写的路径和文件。 部分摘录如下： <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dirs/var/log</span><br><span class="line">empty/tmp</span><br><span class="line">files/etc/adjtime</span><br></pre></td></tr></table></figure> 当在图形界面登陆系统时，在登陆账户下的.ICEauthority会被系统刷新，如果此时账户为只读，则会弹出如下警告，以root账户为例。 <img src="http://wx3.sinaimg.cn/mw690/6a6ccd8fly1fznu7qeo5ej20cw03t0sz.jpg" alt="图1" /> 为了解决这个问题，需要将/root设置为可读写属性。因此在/etc/rwtab添加如下字段： &gt; files /root</p><p>表示将/root账户下的文件设置为可读写。同理，如果有其他账户，则需要一并设置。</p><blockquote><p>/etc/rc.sysinit</p></blockquote><p>实际上这个文件是rc.d/rc.sysinit的软连接。这个文件是系统启动流程，早期阶段的一个关键脚本，将会依据上述配置文件，对文件系统的挂载进行处理。脚本内容比较多，只摘录了跟配置方案相关的这段： <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">if [ -f /etc/sysconfig/readonly-root ]; then</span><br><span class="line">. /etc/sysconfig/readonly-root</span><br><span class="line">Fi</span><br><span class="line"></span><br><span class="line">if [ &quot;$READONLY&quot; = &quot;yes&quot; -o &quot;$TEMPORARY_STATE&quot; = &quot;yes&quot; ]; then</span><br><span class="line">for file in /etc/rwtab /etc/rwtab.d/* /dev/.initramfs/rwtab ; do</span><br><span class="line">is_ignored_file &quot;$file&quot; &amp;&amp; continue</span><br><span class="line">[ -f $file ] &amp;&amp; cat $file | while read type path ; do</span><br><span class="line">case &quot;$type&quot; in</span><br><span class="line">empty)</span><br><span class="line">mount_empty $path</span><br><span class="line">;;</span><br><span class="line">files)</span><br><span class="line">mount_files $path</span><br><span class="line">;;</span><br><span class="line">dirs)</span><br><span class="line">mount_dirs $path</span><br><span class="line">;;</span><br><span class="line">*)</span><br><span class="line">;;</span><br><span class="line">esac</span><br><span class="line">[ -n &quot;$SELINUX_STATE&quot; -a -e &quot;$path&quot; ] &amp;&amp; restorecon -R &quot;$path&quot;</span><br><span class="line">done</span><br><span class="line">done</span><br><span class="line">fi</span><br></pre></td></tr></table></figure></p><p>这段脚本作用是判断/etc/sysconfig/readonly-root文件会否存在，存在则将其中关键字加到环境变量，然后解析/etc/rwtab文件，从中匹配<code>$type</code>关键字并执行对应case脚本函数。 mount_empty作用是将<code>$path</code>路径拷贝到<code>$RW_MOUNT</code>路径（/etc/sysconfig/readonly-root中的关键字），这里只拷贝路径，empty顾名思义就是不包含路径下的子路径和文件。 mount_files作用是将<code>$path</code>路径下的文件拷贝到<code>$RW_MOUNT</code>路径，包含文件夹； mount_dirs作用是将<code>$path</code>路径下的文件夹依照原样的路径结构拷贝到<code>$RW_MOUNT</code>路径； 拷贝完成后，执行 &gt; mount -n --bind &quot;$RW_MOUNT$1&quot; &quot;$1&quot;</p><p>这段就是整个方案的核心思路：将需要读写属性的文件及文件夹原样拷贝到具有读写权限的/var/lib/stateless/writable路径下，随后执行mount --bind将对应路径挂回原路径，实现这部分文件可读写而不影响其他文件。 配置好后就会出现如下图的效果，/root路径的文件系统类型是tmpfs可读写，而系统其他路径则是readonly。 <img src="http://wx2.sinaimg.cn/mw690/6a6ccd8fly1fznurt3mb5j20c601xjrd.jpg" alt="图2" /> 当需要对根文件系统读写修改时，执行 &gt; mount -o remount rw /</p><p>可临时的将文件系统重新赋予读写属性。 需要将系统永久恢复时，此时修改/etc/sysconfig/readonly-root配置文件，将READONLY和TEMPORARY_STATE的键值YES修改为NO即可。</p><hr /><h1 id="case2-方案实施">Case2-方案实施</h1><blockquote><p>Linux发行版操作系统Red Hat Enterprise Linux 7.1 64位</p></blockquote><p>本想使用上述步骤配置完成需求，但发现RHEL7.1已经开始使用systemd做系统启动和服务管理，已经不存在/etc/rc.sysinit脚本，也就无法按照第一集的步骤将系统配置成只读属性。 幸运的是，在systemd的既定框架内，rhel采用rhel-readonly.service服务将原先低版本系统的/etc/rc.sysinit脚本取而代之。如下图所示，该服务已经默认启动。 <img src="http://wx3.sinaimg.cn/mw690/6a6ccd8fly1fznv0tavupj20l102sglp.jpg" alt="图3" /> 查看/usr/lib/systemd/system/rhel-readonly.service服务脚本，分析后发现与/etc/rc.sysinit脚本大同小异，也就存在将文件系统配置成只读模式的可行性。</p><blockquote><p>/etc/sysconfig/readonly-root READONLY=yes TEMPORARY_STATE=yes</p></blockquote><p>READONLY和TEMPORARY_STATE设置成yes，使能只读模式。 其他键值按需求配置，这里默认即可。</p><p>将/root设置为可读写属性,因此在/etc/rwtab添加如下字段： &gt; files /root</p><p>表示将/root账户下的文件设置为可读写。 同理，如果有其他账户，则需要一并设置。以保证在登陆账户时，该账户下的.ICEauthority能顺利被系统刷新。</p><blockquote><p>/etc/fstab</p></blockquote><p>这一步是与Case1中最大的区别。需要手动将/分区设置成“ro”挂载属性，如下图所示： <img src="http://wx2.sinaimg.cn/mw690/6a6ccd8fly1fznv0ws917j20nv06bmxf.jpg" alt="图4" /> 分析原因，推测可能是systemd并不是完全依赖rhel-readonly.service进行readonly的设置，需要/etc/fstab的配合。 执行上述三步后重启，即可完成只读模式的配置。</p><p>PS: 上图/etc/fstab中/cr分区是应用程序的部署分区。如上图所示，添加对应条目，即可按照需求配置成rw属性，其他分区配置同理。</p><hr /><h1 id="case2-问题">Case2-问题</h1><blockquote><p>操作系统只读需求，安装好系统，使用一段时间后，发现系统内存耗尽，且不同板卡，内存消耗程度不同。系统版本RHEL7.2。</p></blockquote><p>问题分析： 其中系统下内存使用状态如下： <img src="http://wx2.sinaimg.cn/mw690/6a6ccd8fly1fznv0z244oj20d505agls.jpg" alt="图5" /> 从图中看出似乎/tmp下被占用了562MB空间，实际分析/tmp并无大文件，此处应该是df命令的解析错误BUG。 对系统其他文件夹分析后，发现/var路径占用过大。 只读属性的文件系统，在硬盘分区配成只读后，会将必须保证读写能力的文件系统路径以tmpfs（内存文件系统）的形式挂载到系统（由/etc/rwtab可配），其中/var路径就是该种情况。 进一步分析/var路径，如下图所示：/var/crash和/var/spool/abrt路径下会存在一些vmcore文件夹，以该板卡为例，/var/spool/abrt下的vmcore文件就已经占用了555MB。 <img src="http://wx2.sinaimg.cn/mw690/6a6ccd8fly1fznv12sc9gj20c803u74d.jpg" alt="图6" /> 该文件是kdump机制生成的用于分析内核崩溃原因的dump文件，该选项在安装系统时可选择是否使能。 通过这个结论可以推出问题的原因： 应用在开发的过程中，可能发生了一些导致内核崩溃的操作，内核依托kdump机制生成了vmcore文件到/var/crash和/var/spool/abrt下，占用了大部分的内存文件系统空间（也即内存空间，甚者会导致1.9G耗尽）</p><p>问题解决： 方案1：已经安装好系统，且系统使能kdump 1、还原文件系统为可读写属性，重启 2、删除/var/crash和/var/spool/abrt下的vmcore文件夹 3、systemctl disable kdump （关闭kdump服务） 4、还原文件系统为只读属性，重启</p><p>方案2：从源头解决。 安装系统过程中，不使能kdump功能。 坏处是，内核崩溃只能实时查看栈信息，无法保存。 可鉴于实际使用环境，自主选择是否使能。</p><p>PS：内存文件系统tmpfs最大为内存的一半，该项目系板卡物理内存4GB，所以tmpfs最大容量为2GB，原则上该上限可由内核选项配置。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;系统是运行在内存中的，硬盘只是系统运行中的存储媒介。当硬盘对应到内存的数据发生改变时，就需要系统将内存的数据同步更新到硬盘进行存储。 异常掉电之所以具备破坏力，是因为异常掉电会不可预知的中断系统将内存数据回写到硬盘的过程，直接导致文件系统数据紊乱。绝大多数带有日志的文件系统（ext3，ext4，xfs等），大多数情况可以依靠文件系统日志自恢复或者依靠fsck命令恢复，问题是并不是所有损坏都可以被修复。 因此，将整个系统设置为只读模式，防止整个回写过程的发生就成了整个方案的出发点。
    
    </summary>
    
      <category term="技术" scheme="http://jxbuaa.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Linux" scheme="http://jxbuaa.github.io/tags/Linux/"/>
    
      <category term="System Configuration" scheme="http://jxbuaa.github.io/tags/System-Configuration/"/>
    
  </entry>
  
  <entry>
    <title>以太网PHY初始化流程</title>
    <link href="http://jxbuaa.github.io/2019/01/%E4%BB%A5%E5%A4%AA%E7%BD%91PHY%E5%88%9D%E5%A7%8B%E5%8C%96%E6%B5%81%E7%A8%8B/"/>
    <id>http://jxbuaa.github.io/2019/01/以太网PHY初始化流程/</id>
    <published>2019-01-28T02:05:35.000Z</published>
    <updated>2019-01-28T15:26:27.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言">前言</h1><p>简单梳理Linux-3.12.37内核以太网PHY芯片初始化基本流程。 <span id="more"></span> Linux-3.12.37 phy驱动匹配流程 1.内核扫描设备树mdio节点，匹配[.compatible = &quot;fsl,fman-mdio&quot;,]-&gt; 2.调用fsl_pq_mdio_probe() —— Fsl_pq_mdio.c (drivers) -&gt; 3.调用of_mdiobus_register()注册mdiobus —— Of_mdio.c (drivers) -&gt; 4.扫描设备树创建struct phy_device *phy设备数据结构 —— Of_mdio.c (drivers) -&gt; 5.调用phy_device_register()注册phy设备数据结构 —— Phy_device.c (drivers) -&gt; 6.调用device_add()将phy设备数据结构的dev添加到dev层级 —— Core.c (drivers) -&gt; 7.调用bus_probe_device()执行dev和driver的匹配 —— Bus.c (drivers) -&gt; 8.调用device_attach() Try to attach device to a driver —— Dd.c (drivers) -&gt; 9.调用bus_for_each_drv(dev-&gt;bus, NULL, dev, _device_attach)枚举 　注册到mdiobus上的驱动 —— Bus.c (drivers) -&gt; 10.枚举所有驱动并逐一执行__device_attach()做最后的dev和driver的匹配 —— Dd.c (drivers) -&gt; 11.调用driver_match_device()执行drv-&gt;bus-&gt;match —— Base.h (drivers) -&gt; 12.驱动接口实例mdio_bus_match() —— Mdio_bus.c (drivers) -&gt; <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bus_type</span> <span class="title">mdio_bus_type</span> =</span> &#123;</span><br><span class="line">.name= <span class="string">&quot;mdio_bus&quot;</span>,</span><br><span class="line">.match= mdio_bus_match,</span><br><span class="line">.pm= MDIO_BUS_PM_OPS,</span><br><span class="line">.dev_attrs= mdio_dev_attrs,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> 13.调用mdio_bus_match()设备和驱动的ID匹配上后，执行driver_probe_device()，进行设备和驱动的关联，如果有probe实例，则执行probe函数 —— Dd.c (drivers) dev-&gt;driver = drv</p><p>另，ifconfig配IP时，会调用phy_attach()接口，Do initial configuration here</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;简单梳理Linux-3.12.37内核以太网PHY芯片初始化基本流程。
    
    </summary>
    
      <category term="技术" scheme="http://jxbuaa.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Driver" scheme="http://jxbuaa.github.io/tags/Driver/"/>
    
      <category term="Linux" scheme="http://jxbuaa.github.io/tags/Linux/"/>
    
      <category term="PHY" scheme="http://jxbuaa.github.io/tags/PHY/"/>
    
  </entry>
  
  <entry>
    <title>PCIE初始化流程</title>
    <link href="http://jxbuaa.github.io/2019/01/PCIE%E5%88%9D%E5%A7%8B%E5%8C%96%E6%B5%81%E7%A8%8B/"/>
    <id>http://jxbuaa.github.io/2019/01/PCIE初始化流程/</id>
    <published>2019-01-28T01:53:20.000Z</published>
    <updated>2019-01-28T14:43:39.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言">前言</h1><p>简单梳理Linux-2-6.23内核，Freescale MPC8548平台初始化及扫描基本流程。 <span id="more"></span> Linux-2-6.23内核，Freescale MPC8548平台PCIE扫描 1.创建控制器host <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mpc85xx_cds_setup_arch -- Mpc85xx_cds.c (arch\powerpc\platforms\<span class="number">85</span>xx)</span><br><span class="line">fsl_add_bridge -- Fsl_pci.c (arch\powerpc\sysdev)</span><br><span class="line">pcibios_alloc_controller -- Pci-common.c (arch\powerpc\kernel)</span><br><span class="line">pci_setup_pci_controller -- Pci-common.c (arch\powerpc\kernel)</span><br></pre></td></tr></table></figure></p><p>2.创建总线bus <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pcibios_init -- Pci_32.c (arch\powerpc\kernel)</span><br><span class="line">pci_scan_bus_parented -- Probe.c (drivers\pci)</span><br><span class="line">pci_create_bus -- Probe.c (drivers\pci)</span><br></pre></td></tr></table></figure></p><p>3.深度扫描设备节点 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pci_scan_child_bus -- Probe.c (drivers\pci)</span><br><span class="line">pci_scan_slot -- Probe.c (drivers\pci)</span><br><span class="line">pci_scan_single_device -- Probe.c (drivers\pci)</span><br><span class="line">pci_scan_device -- Probe.c (drivers\pci)</span><br><span class="line">alloc_pci_dev -- Probe.c (drivers\pci) -&gt; 创建pcie设备节点</span><br></pre></td></tr></table></figure></p><p>4.扫描结束创建irq映射关系 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pcibios_fixup_bus -- Pci_32.c (arch\powerpc\kernel)</span><br><span class="line">pci_read_irq_line -- Pci-common.c (arch\powerpc\kernel)<span class="number">12528</span><span class="number">2015</span><span class="number">-12</span><span class="number">-21</span></span><br><span class="line">of_irq_map_pci -- Pci-common.c (arch\powerpc\kernel) -&gt; 从设备树获取irq信息</span><br><span class="line">pci_device_to_OF_node -- Pci_32.c (arch\powerpc\kernel)</span><br><span class="line">pci_busdev_to_OF_node -- Pci_32.c (arch\powerpc\kernel)</span><br><span class="line">irq_create_of_mapping -- Irq.c (arch\powerpc\kernel)-&gt; 创建虚拟irq 即 virq</span><br><span class="line"><span class="comment">/* If host has no translation, then we assume interrupt line */</span></span><br><span class="line"><span class="keyword">if</span> (host-&gt;ops-&gt;xlate == <span class="literal">NULL</span>)</span><br><span class="line">hwirq = intspec[<span class="number">0</span>];</span><br><span class="line">virq = irq_create_mapping(host, hwirq)</span><br></pre></td></tr></table></figure></p><p>至此将硬件irq和虚拟irq关联 设备在创建驱动时，注册对应该设备的virq</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;简单梳理Linux-2-6.23内核，Freescale MPC8548平台初始化及扫描基本流程。
    
    </summary>
    
      <category term="技术" scheme="http://jxbuaa.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Driver" scheme="http://jxbuaa.github.io/tags/Driver/"/>
    
      <category term="Linux" scheme="http://jxbuaa.github.io/tags/Linux/"/>
    
      <category term="PCIE" scheme="http://jxbuaa.github.io/tags/PCIE/"/>
    
  </entry>
  
  <entry>
    <title>RapidIO递归枚举流程</title>
    <link href="http://jxbuaa.github.io/2019/01/RapidIO%E9%80%92%E5%BD%92%E6%9E%9A%E4%B8%BE%E6%B5%81%E7%A8%8B/"/>
    <id>http://jxbuaa.github.io/2019/01/RapidIO递归枚举流程/</id>
    <published>2019-01-28T01:30:45.000Z</published>
    <updated>2019-01-28T14:42:36.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言">前言</h1><p>简单梳理内核RapidIO递归枚举节点基本流程。 <span id="more"></span> 1.rio_mport_is_active读取0x158 (port0), 0x178 (port1), 0x198 (port2),....0x338 (port15)寄存器来判断该mport对应的port口是否处于active &gt; The input and output ports are initialized and the port is exchanging error-free control symbols with the attached device.</p><p>2.枚举时，rio_mport_chk_dev_access通过判断RIO_DEV_ID_CAR（0x0）寄存器的值，来判断对应跳数下的设备是否能够顺利访问</p><p>3.主体枚举函数 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">rio_enum_peer</span><span class="params">(struct rio_net *net, struct rio_mport *port,u8 hopcount, struct rio_dev *prev, <span class="keyword">int</span> prev_port)</span></span></span><br></pre></td></tr></table></figure></p><p>4.找到新设备以后，调用rio_setup_device读取该设备相关属性并建立设备链表节点 　　4.1 读RIO_PEF_CAR（0x10）判断该设备类型（EP or SWITCH）； 　　4.2 读取RIO_SWP_INFO_CAR（0x14）判断该SWITCH有多少port，当前维护空间访问的对应port 　　4.3 读取RIO_DEV_ID_CAR（0x0）设备ID，厂商ID 　　4.4 如果该设备是SWITCH，则初始化清空路由表</p><p>5.rio_enum_peer判断该设备是否是SWITCH，是则按照port数量建立路由表 　　5.1 扫描各个port，调用rio_sport_is_active判断交换机的该port是否处于active（同1） 　　　　5.1.1 如果交换机的该port是acrive，则添加路由节点至SWITCH寄存器0x70、0x74 ， 　　　　　　　并标记（rswitch-&gt;port_ok）。 　　　　　　　深度优先，跳数+1，递归调用rio_enum_peer继续在该port下枚举（每个port枚举到底） 　　　　5.1.2 如果该port非active，则置位该port的0x15c寄存器Port lockout位, 　　　　　　　并标记（rswitch-&gt;port_ok） &gt; This port is stopped and is not enabled to issue or receive any packets</p><h1 id="结束语">结束语</h1><p>discover的流程跟enumerate基本一致。 核心思想：深度轮询各个port，往0x70写入id，从0x74读回port值，比对当前轮询的port。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;简单梳理内核RapidIO递归枚举节点基本流程。
    
    </summary>
    
      <category term="技术" scheme="http://jxbuaa.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Driver" scheme="http://jxbuaa.github.io/tags/Driver/"/>
    
      <category term="Linux" scheme="http://jxbuaa.github.io/tags/Linux/"/>
    
      <category term="RapidIO" scheme="http://jxbuaa.github.io/tags/RapidIO/"/>
    
  </entry>
  
  <entry>
    <title>网卡研究一：驱动框架剖析</title>
    <link href="http://jxbuaa.github.io/2019/01/%E7%BD%91%E5%8D%A1%E7%A0%94%E7%A9%B6%E4%B8%80%EF%BC%9A%E9%A9%B1%E5%8A%A8%E6%A1%86%E6%9E%B6%E5%89%96%E6%9E%90/"/>
    <id>http://jxbuaa.github.io/2019/01/网卡研究一：驱动框架剖析/</id>
    <published>2019-01-27T08:49:25.000Z</published>
    <updated>2022-02-09T03:11:23.664Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言">前言</h1><p>本系列计划以<font color=red>优化网卡侧UDP高速小包抓取</font>需求为着力点， 从<strong>网卡驱动分析</strong>、<strong>网卡多队列中断均衡优化</strong>、<strong>网卡侧零拷贝抓取</strong>实现三个递进深度详细阐述网卡驱动的工作机制。 作为系列第一作，本文以Intel 82580、Intel 82571/4两款网卡为对象， 详细分析<strong>网卡驱动的数据结构管理</strong>、<strong>多队列/单队列收发包处理</strong>、<strong>NAPI调用机制</strong>等模块，为后续的优化工作打下基础。 <span id="more"></span> 操作系统：RHEL7.2 内核版本：linux-3.10.0-327.el7.x86_64 驱动框架： Intel 82580：igb Intel 82571/4：e1000e</p><h1 id="数据结构框图分析">数据结构框图分析</h1>多队列网卡是以后网卡能力的基本配置，也是性能提升的基础。 因此首先分析Intel 82580：igb驱动框架。网卡硬件框架如图1所示，驱动数据结构和数据流关系如图2所示： <img src="http://wx1.sinaimg.cn/mw690/6a6ccd8fly1fzl8damuxlj20nx0h2n01.jpg" alt="图1" /><p align="center">图1 网卡硬件框架</p><img src="http://wx4.sinaimg.cn/mw690/6a6ccd8fly1fzl8ddejr0j21790qymzg.jpg" alt="图2" /><p align="center">图2 驱动数据结构和数据流关系</p>图2中黑色箭头表RX数据结构关系，<font color=red>红色箭头</font>表示TX数据结构关系。首先从数据流的角度简要分析： <img src="http://wx3.sinaimg.cn/mw690/6a6ccd8fly1fzl9galhi2j20qh0b4q3o.jpg" alt="图3" /><p align="center">图3 硬件队列指针</p><p>RX：网卡硬件MAC层收到数据后，根据驱动初始化配置好的rx_desc接收缓冲描述符，利用DMA将硬件RX FIFO中的数据拷贝到内核缓冲rx_buffer中，接收缓冲是以内存page页为管理对象。随后经过驱动处理，将rx_buffer中对应page页挂接到skb中，skb为整个内核网络数据流管理的对象。内核协议栈收到skb后针对不同协议要求进行处理，最后将净载荷拷贝至用户层完成RX工作。 TX：用户层调用网络send接口，内核将数据拷贝至skb管理的缓冲。随后经过驱动处理，直接将skb-&gt;data对应的内核缓冲以流式DMA映射的方式拿到对应的page页，填充到tx_desc描述符中，并在最后一帧的描述符tx_desc中将EOP(End of Packet)置位，同时更新硬件指针如图3所示。网卡通过硬件指针检测到有待发数据，利用DMA将内核缓冲中的数据拷贝至硬件TX FIFO中发送到对端计算机。</p><h1 id="数据结构详细分析">数据结构详细分析</h1>下面对驱动中的具体数据结构如图4所示进行分析。由于数据结构多且复杂，转成图4画质较低。 图中黑色箭头及①类数字表示RX相关数据结构，<font color=red>红色箭头</font>及❶类数字表示TX相关数据结构。 <img src="http://wx4.sinaimg.cn/mw690/6a6ccd8fly1fzl8dl4ydpj217b0q5teu.jpg" alt="图4" /><p align="center">图4 驱动数据结构</p><p>8核CPU下的82580网卡驱动默认属性如下： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* set default ring sizes */</span></span><br><span class="line">adapter-&gt;tx_ring_count = IGB_DEFAULT_TXD = <span class="number">256</span>;</span><br><span class="line">adapter-&gt;rx_ring_count = IGB_DEFAULT_RXD = <span class="number">256</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* set default ITR values */</span></span><br><span class="line">adapter-&gt;rx_itr_setting = IGB_DEFAULT_ITR = <span class="number">3</span>;</span><br><span class="line">adapter-&gt;tx_itr_setting = IGB_DEFAULT_ITR = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* set default work limits */</span></span><br><span class="line">adapter-&gt;tx_work_limit = IGB_DEFAULT_TX_WORK = <span class="number">128</span>;</span><br><span class="line"></span><br><span class="line">max_rss_queues = IGB_MAX_RX_QUEUES = <span class="number">8</span></span><br><span class="line"></span><br><span class="line">adapter-&gt;rss_queues = <span class="keyword">min_t</span>(u32, max_rss_queues, num_online_cpus()) = <span class="number">8</span></span><br><span class="line"></span><br><span class="line">adapter-&gt;num_rx_queues = adapter-&gt;rss_queues = <span class="number">8</span></span><br><span class="line">adapter-&gt;num_tx_queues = adapter-&gt;rss_queues = <span class="number">8</span></span><br><span class="line"></span><br><span class="line">adapter-&gt;num_q_vectors = numvecs = <span class="number">8</span></span><br></pre></td></tr></table></figure> 针对每个网卡接口，内核会抽象adapter数据结构，根据82580网卡支持收发各8个硬件队列属性，该adapter包含8个struct igb_q_vector数据结构。 RX： ① igb_q_vector包含tx，rx各一个struct igb_ring_container，用以维护ring属性； ② igb_q_vector包含tx，rx各一个struct igb_ring，用以维护ring具体属性，是整个网卡管理核心数据结构； ③ 每个队列对应各自硬件中断，各自igb_q_vector，各自napi_struct数据结构，各自napi poll回调接口以轮询处理网卡数据包； ④ rx igb_ring根据网卡属性配置IGB_DEFAULT_RXD = 256分配256个igb_rx_buffer，用以维护rx buffer物理地址及对应page页，填充rx_desc描述符。同时维护skb数据结构，在rx buffer收到数据后，关联skb送入协议栈进行处理； ⑤ rx igb_ring根据网卡属性配置IGB_DEFAULT_RXD = 256分配256个adv_rx_desc，用以维护硬件描述符，是软件与硬件交互的关键数据结构； ⑥ igb_rx_buffer及adv_rx_desc数据结构通过dma_map_page指向同一page页，为接收硬件DMA数据实体 TX： ❶ 用户态通过拷贝数据，将数据传入内核协议栈； ❷ 协议栈以skb为管理对象，将数据依托skb传入igb_tx_buffer； ❸ 驱动将skb-&gt;data以dma_map_single（流式DMA映射 ）方式拿到物理地址，填充adv_tx_desc描述符；</p><h1 id="函数接口调用分析">函数接口调用分析</h1><p>在进行下述分析前，先引入几个概念，取自linux-3.10.0-327.el7.txt，这里放上网上找来的部分翻译版本便于快速理解，建议读原文： - RSS: Receive Side Scaling ———————————— 当代的NICs支持多个接收和传输队列，即多队列。接收的时候，一个网卡能够发送不同的包到不同的队列，为了在不同的CPU之间分散处理。<font color=red>NIC针对每一个包，通过一个过滤器来指定这个包属于少数几个流中的一个流。每个流中的数据包被控制在一个单独的接收队列中，而队列轮回的被CPU进行处理</font>。这种机制就叫做RSS。RSS的目标和其他控制技术目的都是为了增加性能。多队列也可以被用于流量优先控制，但那不是这些技术的目的。 RSS中的过滤器是一个基于L3和L4层头部的hash函数，例如，基于IP地址和TCP端口的4元组的hash函数。最常见的RSS硬件实现中，使用了128个间接表，其中每个表存储一个队列号(注，网卡的队列数比较少，比如igb是8个，bnx2是5个)。针对某个包而言，使用这个包计算出的hash值（hash是Toeplitz算法）的低7位先确定间接表，再从间接表中的值访问队列。一些高级的NICs允许使用可编程的过滤器来控制包属于哪个队列。例如，绑定TCP端口80的webserver，数据包能被指向他们自己的队列。</p><ul><li><p>RPS: Receive Packet Steering ———————————— RPS，逻辑上是一种以软件的方式来实现RSS。在数据路径上，稍后被调用。介于RSS选择了队列和CPU(这个cpu会处理硬中断)，<font color=red>RPS选择CPU来执行硬件中断处理之后的协议处理。通过把数据包放在目标CPU的backlog队列，并唤醒CPU来处理</font>。RPS相比RSS有几个好处： 1） RPS能够被任何NIC使用。 2） 软件过滤器能够轻易的被添加，用来hash新的协议。 3） 它不会增加硬件设备的中断。尽管，引入了IPIs(inter-processor interrupts)。 当一个设备使用 netif_rx() 函数和netif_receive_skb()函数，(从网卡驱动)向网络协议栈传递数据包时，RPS在底半环境（通过软中断来实现的，在硬中断处理函数之后。）中被调用。这2个函数调用get_rps_cpu()函数，来选择应该执行包的队列。决定目标CPU的第一步是基于包的地址和端口（有的协议是2元组，有的协议是4元组）来计算hash值。这个值与这个包的流保持一致。这个hash值要么是由硬件来提供的， 要么是由协议栈来计算的。厉害的硬件能够在包的接收描述符中传递hash值，这个值与RSS计算的值是相等的。这个hash值保存在skb-&gt;rx_hash中，并且这个值可以作为流的hash值可以被使用在栈的其他任何地方。每一个接收硬件队列有一个相关的CPU列表，RPS可以将包放到这个队列中进行处理。对于每一个接收到的包，指向这个列表的索引是通过流hash值对列表大小取模来计算的。被指向的CPU是处理 数据包的目标CPU，并且这个包被加到CPU的backlog队列的尾部。最底半处理的最后，IPI被发送到这个包所插到的那个CPU。IPI唤醒远程CPU来处理backlog队列，之后队列中数据包被发送到网络协议栈进行处理。</p></li><li><p>RFS: Receive Flow Steering ————————————<br />RPS只依靠hash来控制数据包，提供了好的负载平衡，但是它没有考虑应用程序的位置(注：这个位置是指程序在哪个cpu上执行)。RFS则考虑到了应用程序的位置。<font color=red>RFS的目标是通过指派应用线程正在运行的CPU来进行数据包处理，以此来增加数据缓存的命中率</font>。RFS依靠RPS的机制插入数据包到指定CPU的backlog队列，并唤醒那个CPU来执行。</p></li><li>XPS: Transmit Packet Steering ———————————— XPS 是一种机制，用来智能的选择多队列设备的队列来发送数据包。为了达到这个目标，从CPU到硬件队列的映射需要被记录。这个映射的目标是专门地分配队列到一个CPU列表，这些CPU列表中的某个CPU来完成队列中的数据传输。这个有两点优势，<font color=red>第一点，设备队列上的锁竞争会被减少，因为只有很少的CPU对相同的队列进行竞争。（如果每个CPU只有自己的传输队列，锁的竞争就完全没有了。）第二点，传输时的缓存不命中的概率就减少，特别是持有sk_buff的数据缓存</font>。 <img src="http://wx3.sinaimg.cn/mw690/6a6ccd8fly1fzl8f0dpw6j20ty0qodip.jpg" alt="图5" /><p align="center">图5 多队列处理框架</p></li></ul><p>简而言之，RSS是为了发挥网卡多队列处理性能，RPS则是软件层将数据包分发到多个CPU上进行处理（同时要保证cache一致性）。对于一个多队列的系统，如果RSS已经配置了，导致一个硬件接收队列已经映射到每一个CPU，那么RPS就是多余的和不必要的；如果只有很少的硬件中断队列(比CPU个数少)，每个队列的rps_cpus指向的CPU列表与这个队列的中断CPU共享相同的内存域，那RPS将会是有效的。RFS则是为了增加内核层切换到用户层的cache命中率，XFS同理。网卡多队列处理框架如图5所示。</p><p>RX： ① 硬件中断顶半部处理，分队列处理； ② 硬件低半部处理； ③ napi轮询回调； ④ 网卡接收数据处理轮询接口，不同队列接收处理的数据，根据五元组hash值入列到依托RPS(Receive Packet Steering)机制选取的CPU的backlog队列，后续的协议栈处理由该CPU处理； ⑤ 在④对应的CPU轮询处理自己的backlog队列，接入协议栈处理； ⑥ IP层数据处理，如果在该层插入自定义协议，则可从该层将符合自定义协议的数据包截获，<font color=red>PF_RING就是利用了这个机制将包截获处理</font>； ⑦ TCP/UDP/ICMP/IGMP等协议处理。</p><p>硬件接收中断 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-&gt; igb_msix_ring  中断服务函数（分队列处理）</span><br></pre></td></tr></table></figure> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-&gt; napi_schedule -&gt; napi_schedule_prep</span><br><span class="line">   检测napi-&gt;state, NAPI_STATE_SCHED是否置位允许napi调度</span><br><span class="line">-&gt; __napi_schedule -&gt; ____napi_schedule </span><br><span class="line">   关闭硬件中断，并将该napi-&gt;poll_list添加到全局轮询队列poll_list</span><br><span class="line">-&gt; __raise_softirq_irqoff(NET_RX_SOFTIRQ) 产生napi软件中断</span><br></pre></td></tr></table></figure> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-&gt; net_rx_action 软中断服务函数</span><br><span class="line">   只要全局poll_list队列不为空，则一直轮询处理</span><br><span class="line">   当轮询完成预设目标任务budget，或者<span class="number">2</span>秒轮询超时后强制退出则结束napi轮询，重新使能中断</span><br><span class="line">-&gt; n-&gt;poll -&gt; igb_poll 回调网卡轮询处理接口</span><br></pre></td></tr></table></figure> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">-&gt; igb_clean_rx_irq</span><br><span class="line">-&gt; igb_alloc_rx_buffers</span><br><span class="line">   判断回收rx_buffer超过IGB_RX_BUFFER_WRITE(<span class="number">16</span>),一次性补充<span class="number">16</span>个buffer</span><br><span class="line">-&gt; igb_fetch_rx_buffer      申请skb并将rx_buffer数据page挂接到skb</span><br><span class="line">-&gt; napi_gro_receive</span><br><span class="line">   判断网卡是否支持GRO(Generic Segmentation Offload)</span><br><span class="line">   相对应的有TSO(TCP Segmentation Offload)</span><br><span class="line">-&gt; napi_skb_finish -&gt; netif_receive_skb</span><br><span class="line">   使能CONFIG_RPS(Receive Packet Steering)时</span><br><span class="line">-&gt; get_rps_cpu              依据skb-&gt;hash获取后续传输层协议栈处理target CPU</span><br><span class="line">-&gt; enqueue_to_backlog -&gt; __skb_queue_tail</span><br><span class="line">   将各个队列的skb入列到对应处理target CPU的input_pkt_queue</span><br></pre></td></tr></table></figure> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-&gt; ____napi_schedule </span><br><span class="line">-&gt; __raise_softirq_irqoff(NET_RX_SOFTIRQ) 产生sd-&gt;backlog软件中断</span><br><span class="line">-&gt; net_rx_action                软中断服务函数</span><br><span class="line">-&gt; n-&gt;poll -&gt; process_backlog回调backlog的轮询处理函数</span><br><span class="line">-&gt; __skb_dequeue            从队列中出列待处理skb</span><br><span class="line">-&gt; __netif_receive_skb -&gt; __netif_receive_skb_core </span><br><span class="line">   开始处理网络层skb</span><br><span class="line">   根据注册skb-&gt;protocol搜索pt_prev <span class="comment">/* Protocol hook */</span></span><br><span class="line">-&gt; deliver_skb -&gt; pt_prev-&gt;func </span><br></pre></td></tr></table></figure> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">-&gt; ip_rcv               IP层数据处理，net/ipv4/af_inet.c注册</span><br><span class="line">   若注册pf_ring的packet_type，则调用pfring rcv</span><br><span class="line">   prot_hook.func = packet_rcv;</span><br><span class="line">   prot_hook.type = htons(ETH_P_ALL);</span><br><span class="line">-&gt; ip_rcv_finish -&gt; dst_input <span class="comment">/* Input packet from network to transport */</span></span><br><span class="line">-&gt; skb_dst(skb)-&gt;input(skb) </span><br><span class="line">-&gt; ip_local_deliver -&gt; ip_defrag <span class="comment">/* Reassemble IP fragments. */</span></span><br><span class="line">-&gt; ip_local_deliver_finish </span><br><span class="line">   根据注册inet_protos搜索ipprot</span><br><span class="line">   tcp_protocol, udp_protocol, icmp_protocol, igmp_protocol等</span><br><span class="line">   在net/ipv4/af_inet.c，inet_init注册，以tcp为例</span><br><span class="line">-&gt; tcp/udp层 -&gt; ipprot-&gt;handler </span><br></pre></td></tr></table></figure> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-&gt; tcp_v4_rcv(udp_rcv) -&gt; tcp_v4_do_rcv </span><br><span class="line">-&gt; tcp_rcv_state_process </span><br><span class="line">-&gt; <span class="keyword">case</span> TCP_ESTABLISHED: tcp_data_queue </span><br><span class="line">-&gt; tcp_queue_rcv </span><br><span class="line">-&gt; __skb_queue_tail <span class="comment">/* queue a buffer at the list tail */</span></span><br></pre></td></tr></table></figure> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-&gt; napi_complete            结束轮询</span><br><span class="line">-&gt; igb_ring_irq_enable重新使能硬件中断</span><br></pre></td></tr></table></figure></p><p>由于发送流程相对一致、简单，这里只对接口功能进行注释，不做赘述。 TX：网络发送流程 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">应用层send -&gt; copy_from_user </span><br><span class="line">-&gt; 内核层skb -&gt; 协议栈 </span><br><span class="line">-&gt; 分队列</span><br><span class="line">-&gt; ndo_start_xmit -&gt; igb_xmit_frame</span><br><span class="line">-&gt; igb_xmit_frame_ring </span><br><span class="line">-&gt; igb_tx_queue_mapping     根据skb-&gt;queue_mapping获取对应发送队列tx_ring</span><br><span class="line">-&gt; igb_xmit_frame_ring      skb填充tx_ring-&gt;tx_buffer_info</span><br><span class="line">-&gt; <span class="function">igb_tso                  <span class="title">TSO</span><span class="params">(TCP Segmentation Offload)</span></span></span><br><span class="line"><span class="function">-&gt; igb_tx_map</span></span><br><span class="line"><span class="function">将skb流式映射dma_map_single填充描述符tx_desc</span></span><br><span class="line"><span class="function">并在最后一帧的描述符tx_desc中将<span class="title">EOP</span><span class="params">(End of Packet)</span>置位</span></span><br></pre></td></tr></table></figure></p><p>硬件发送完成中断 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">-&gt; igb_msix_ring                            中断服务函数（分队列处理）</span><br><span class="line">-&gt; napi_schedule -&gt; napi_schedule_prep</span><br><span class="line">   检测napi-&gt;state, NAPI_STATE_SCHED是否置位允许napi调度</span><br><span class="line">-&gt; __napi_schedule -&gt; ____napi_schedule </span><br><span class="line">   关闭硬件中断，并将该napi-&gt;poll_list添加到全局轮询队列poll_list</span><br><span class="line">-&gt; __raise_softirq_irqoff(NET_RX_SOFTIRQ)   产生napi软件中断</span><br><span class="line">-&gt; net_rx_action                            软中断服务函数</span><br><span class="line">   只要全局poll_list队列不为空，则一直轮询处理</span><br><span class="line">   当轮询完成预设目标任务budget，或者<span class="number">2</span>秒轮询超时后强制退出则结束napi轮询，重新使能中断</span><br><span class="line">-&gt; n-&gt;poll -&gt; igb_poll                      回调网卡轮询处理接口   </span><br><span class="line">-&gt; igb_clean_tx_irq                     释放skb，dma_unmap_single</span><br></pre></td></tr></table></figure></p><h1 id="结束语">结束语</h1><p>本文在对Intel82580网卡驱动分析的基础上，梳理了各部数据结构间的关联关系，总结了网卡收发数据流的处理流程。 那么，多队列和CPU中断之间均衡处理关系到底应该如何优化，中断均衡是否能够带来实质性的性能提升，落实到具体实测数据多队列网卡表现又是如何，请看网卡研究二：中断均衡优化。</p><p>PS：在研究之初对网卡队列并没有过多的理解，所以选择了单队列网卡Intel 82574（e1000e）开始分析，其数据结构关系和收发流程与多队列网卡大同小异，在此不做赘述。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;本系列计划以&lt;font color=red&gt;优化网卡侧UDP高速小包抓取&lt;/font&gt;需求为着力点， 从&lt;strong&gt;网卡驱动分析&lt;/strong&gt;、&lt;strong&gt;网卡多队列中断均衡优化&lt;/strong&gt;、&lt;strong&gt;网卡侧零拷贝抓取&lt;/strong&gt;实现三个递进深度详细阐述网卡驱动的工作机制。 作为系列第一作，本文以Intel 82580、Intel 82571/4两款网卡为对象， 详细分析&lt;strong&gt;网卡驱动的数据结构管理&lt;/strong&gt;、&lt;strong&gt;多队列/单队列收发包处理&lt;/strong&gt;、&lt;strong&gt;NAPI调用机制&lt;/strong&gt;等模块，为后续的优化工作打下基础。
    
    </summary>
    
      <category term="技术" scheme="http://jxbuaa.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Driver" scheme="http://jxbuaa.github.io/tags/Driver/"/>
    
      <category term="Linux" scheme="http://jxbuaa.github.io/tags/Linux/"/>
    
      <category term="NIC" scheme="http://jxbuaa.github.io/tags/NIC/"/>
    
  </entry>
  
  <entry>
    <title>Hexo_NexT主题配置</title>
    <link href="http://jxbuaa.github.io/2019/01/Hexo_NexT%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/"/>
    <id>http://jxbuaa.github.io/2019/01/Hexo_NexT主题配置/</id>
    <published>2019-01-26T16:37:37.000Z</published>
    <updated>2022-02-09T06:43:28.563Z</updated>
    
    <content type="html"><![CDATA[<h1 id="hexo-next主题定制化修改">Hexo NexT主题定制化修改</h1><p>折腾几天，总算是有了自己的Blog，也算是一个新的开始。 NexT主题的装修也零零散散花了些时间，期间也参考了不少其他博主的配置，总算 是部署成自己比较钟意的样式了。 <span id="more"></span> 为了便于之后的维护，对NexT主题配置文件的修改记录如下：</p><p>1.修改<strong>languages-Hans.yml</strong><br /><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">修改</span><br><span class="line">overview: 站点概览 -&gt; 关于作者</span><br><span class="line">in: 分类于 -&gt; 分类</span><br><span class="line">添加</span><br><span class="line">commentcount: 评论数</span><br></pre></td></tr></table></figure></p><p>2.修改<strong>layout_macro.swig</strong> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">在“评论数”的符号后添加中文描述</span><br><span class="line">&lt;span <span class="class"><span class="keyword">class</span>=</span><span class="string">&quot;post-meta-item-text&quot;</span>&gt;&#123;&#123;__(<span class="string">&#x27;post.commentcount&#x27;</span>)&#125;&#125;&amp;#<span class="number">58</span>;&lt;/span&gt;</span><br><span class="line"></span><br><span class="line">分享图标后面添加描述</span><br><span class="line">&lt;i <span class="class"><span class="keyword">class</span>=</span><span class="string">&quot;fa fa-share-alt&quot;</span> aria-hidden=<span class="string">&quot;true&quot;</span>&gt;分享页面|Share&lt;/i&gt;</span><br><span class="line"></span><br><span class="line">在文章末尾添加“The End”标记</span><br><span class="line">&lt;div&gt;</span><br><span class="line">    &#123;% <span class="keyword">if</span> <span class="keyword">not</span> is_index %&#125;</span><br><span class="line">    &#123;% include <span class="string">&#x27;passage-end-tag.swig&#x27;</span> %&#125;</span><br><span class="line">    &#123;% endif %&#125;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">修改文件结尾标签前的“#”为标签图标</span><br><span class="line">&lt;a href=<span class="string">&quot;&#123;&#123; url_for(tag.path) &#125;&#125;&quot;</span> rel=<span class="string">&quot;tag&quot;</span>&gt;&lt;i class=<span class="string">&quot;fa fa-tag&quot;</span>&gt;&lt;/i&gt; &#123;&#123; tag.name &#125;&#125;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">添加置顶功能执行</span><br><span class="line">$ npm uninstall hexo-generator-index --save</span><br><span class="line">$ npm install hexo-generator-index-pin-top --save</span><br><span class="line">添加置顶功能标签，插入到&lt;div class=<span class="string">&quot;post-meta&quot;</span>&gt;标签下</span><br><span class="line">&#123;% <span class="keyword">if</span> post.top %&#125;</span><br><span class="line">&lt;i class=<span class="string">&quot;fa fa-thumb-tack&quot;</span>&gt;&lt;/i&gt;</span><br><span class="line">&lt;font color=<span class="number">000000</span>&gt;置顶&lt;/font&gt;</span><br><span class="line">&lt;span class=<span class="string">&quot;post-meta-divider&quot;</span>&gt;|&lt;/span&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure></p><p>3.修改<strong>layout_partials.swig</strong> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">修改页面底部用户名前面的图标</span><br><span class="line">&lt;i <span class="class"><span class="keyword">class</span>=</span><span class="string">&quot;fa fa-address-card&quot;</span>&gt;&lt;/i&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><p>4.修改<strong>layout_partials.swig</strong> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">添加如下段，配合DaoVoice的使能功能</span><br><span class="line">&#123;% <span class="keyword">if</span> theme.daovoice %&#125;</span><br><span class="line">  &lt;script&gt;  (function(i,s,o,g,r,a,m)&#123;i[<span class="string">&quot;DaoVoiceObject&quot;</span>]=r;i[r]=i[r]||function()&#123;(i[r].q=i[r].q||[]).push(arguments)&#125;,i[r].l=<span class="number">1</span>*<span class="keyword">new</span> Date();a=s.createElement(o),m=s.getElementsByTagName(o)[<span class="number">0</span>];a.async=<span class="number">1</span>;a.src=g;a.charset=<span class="string">&quot;utf-8&quot;</span>;m.parentNode.insertBefore(a,m)&#125;)(window,document,<span class="string">&quot;script&quot;</span>,(<span class="string">&#x27;https:&#x27;</span> == document.location.protocol ? <span class="string">&#x27;https:&#x27;</span> : <span class="string">&#x27;http:&#x27;</span>) + <span class="string">&quot;//widget.daovoice.io/widget/0f81ff2f.js&quot;</span>,<span class="string">&quot;daovoice&quot;</span>)</span><br><span class="line">  daovoice(<span class="string">&#x27;init&#x27;</span>, &#123;</span><br><span class="line">      app_id: <span class="string">&quot;&#123;&#123;theme.daovoice_app_id&#125;&#125;&quot;</span></span><br><span class="line">    &#125;);</span><br><span class="line">  daovoice(<span class="string">&#x27;update&#x27;</span>);</span><br><span class="line">  &lt;/script&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure></p><p>5.修改<strong>layout_layout.swig</strong> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">添加如下段，使能首页右上角github链接</span><br><span class="line">&lt;a href=<span class="string">&quot;https://github.com/jxbuaa&quot;</span> class=<span class="string">&quot;github-corner&quot;</span> aria-label=<span class="string">&quot;View source on GitHub&quot;</span>&gt;&lt;svg width=<span class="string">&quot;80&quot;</span> height=<span class="string">&quot;80&quot;</span> viewBox=<span class="string">&quot;0 0 250 250&quot;</span> style=<span class="string">&quot;fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;&quot;</span> aria-hidden=<span class="string">&quot;true&quot;</span>&gt;&lt;path d=<span class="string">&quot;M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z&quot;</span>&gt;&lt;/path&gt;&lt;path d=<span class="string">&quot;M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2&quot;</span> fill=<span class="string">&quot;currentColor&quot;</span> style=<span class="string">&quot;transform-origin: 130px 106px;&quot;</span> class=<span class="string">&quot;octo-arm&quot;</span>&gt;&lt;/path&gt;&lt;path d=<span class="string">&quot;M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z&quot;</span> fill=<span class="string">&quot;currentColor&quot;</span> class=<span class="string">&quot;octo-body&quot;</span>&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;&lt;style&gt;.github-corner:hover .octo-arm&#123;animation:octocat-wave <span class="number">560</span>ms ease-in-out&#125;@keyframes octocat-wave&#123;<span class="number">0</span>%,<span class="number">100</span>%&#123;transform:rotate(<span class="number">0</span>)&#125;<span class="number">20</span>%,<span class="number">60</span>%&#123;transform:rotate(<span class="number">-25</span>deg)&#125;<span class="number">40</span>%,<span class="number">80</span>%&#123;transform:rotate(<span class="number">10</span>deg)&#125;&#125;@media (max-width:<span class="number">500</span>px)&#123;.github-corner:hover .octo-arm&#123;animation:none&#125;.github-corner .octo-arm&#123;animation:octocat-wave <span class="number">560</span>ms ease-in-out&#125;&#125;&lt;/style&gt;</span><br><span class="line"></span><br><span class="line">在swig末尾，&lt;/body&gt;前添加</span><br><span class="line">&lt;!-- 代码块复制功能 --&gt;</span><br><span class="line">&lt;script type=<span class="string">&quot;text/javascript&quot;</span> src=<span class="string">&quot;/js/src/clipboard.min.js&quot;</span>&gt;&lt;/script&gt;  </span><br><span class="line">&lt;script type=<span class="string">&quot;text/javascript&quot;</span> src=<span class="string">&quot;/js/src/clipboard-use.js&quot;</span>&gt;&lt;/script&gt; </span><br></pre></td></tr></table></figure></p><p>6.在**source*下添加两个js实现代码copy功能 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">clipboard.min.js</span><br><span class="line">clipboard-use.js</span><br></pre></td></tr></table></figure></p><p>7.修改<strong>source_common-author.styl</strong> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">添加如下段，势能圆形头像和动态旋转效果</span><br><span class="line">border-radius: <span class="number">50</span>%;</span><br><span class="line">transition: <span class="number">1.5</span>s all;  </span><br><span class="line">.site-author-image:hover &#123;</span><br><span class="line">    transform: rotate(<span class="number">360</span>deg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>8.修改<strong>source_custom.styl</strong> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 修改网站头部颜色</span></span><br><span class="line"><span class="comment">/* .headband &#123;</span></span><br><span class="line"><span class="comment">    height: 3px;</span></span><br><span class="line"><span class="comment">    background: #bbb;</span></span><br><span class="line"><span class="comment">&#125; */</span></span><br><span class="line">.site-meta &#123;</span><br><span class="line">    padding: <span class="number">40</span>px <span class="number">0</span>;</span><br><span class="line">    color: <span class="meta">#fff;</span></span><br><span class="line">    background: $winered;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.site-subtitle &#123;</span><br><span class="line">    <span class="comment">// margin-top: 10px;</span></span><br><span class="line">    <span class="comment">// font-size: 13px;</span></span><br><span class="line">    color: <span class="meta">#ffffff;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改无序列表前的符号为&#x27;.&#x27;</span></span><br><span class="line">.posts-expand .post-body &#123;</span><br><span class="line">  ul li &#123; <span class="built_in">list</span>-style: square; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 鼠标移动至文章标题时的效果</span></span><br><span class="line">.posts-expand .post-title-link &#123;</span><br><span class="line">  &amp;::before &#123;</span><br><span class="line">    height: <span class="number">1</span>px;</span><br><span class="line">    background-color: $winered;</span><br><span class="line">  transition-duration: <span class="number">0</span>s;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  &amp;:hover &#123;</span><br><span class="line">    color: $winered;</span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//代码块复制按钮</span></span><br><span class="line">.highlight&#123;</span><br><span class="line">  <span class="comment">//方便copy代码按钮（btn-copy）的定位</span></span><br><span class="line">  position: relative;</span><br><span class="line">&#125;</span><br><span class="line">.btn-copy &#123;</span><br><span class="line">    display: <span class="keyword">inline</span>-block;</span><br><span class="line">    cursor: pointer;</span><br><span class="line">    background-color: <span class="meta">#eee;</span></span><br><span class="line">    background-image: linear-gradient(<span class="meta">#fcfcfc,#eee);</span></span><br><span class="line">    border: <span class="number">1</span>px solid #d5d5d5;</span><br><span class="line">    border-radius: <span class="number">3</span>px;</span><br><span class="line">    -webkit-user-select: none;</span><br><span class="line">    -moz-user-select: none;</span><br><span class="line">    -ms-user-select: none;</span><br><span class="line">    user-select: none;</span><br><span class="line">    -webkit-appearance: none;</span><br><span class="line">    font-size: <span class="number">13</span>px;</span><br><span class="line">    font-weight: <span class="number">700</span>;</span><br><span class="line">    line-height: <span class="number">20</span>px;</span><br><span class="line">    color: #<span class="number">333</span>;</span><br><span class="line">    -webkit-transition: opacity <span class="number">.3</span>s ease-in-out;</span><br><span class="line">    -o-transition: opacity <span class="number">.3</span>s ease-in-out;</span><br><span class="line">    transition: opacity <span class="number">.3</span>s ease-in-out;</span><br><span class="line">    padding: <span class="number">2</span>px <span class="number">6</span>px;</span><br><span class="line">    position: absolute;</span><br><span class="line">    right: <span class="number">5</span>px;</span><br><span class="line">    top: <span class="number">5</span>px;</span><br><span class="line">    opacity: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">.btn-copy span &#123;</span><br><span class="line">    margin-left: <span class="number">5</span>px;</span><br><span class="line">&#125;</span><br><span class="line">.highlight:hover .btn-copy&#123;</span><br><span class="line">  opacity: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>9.修改<strong>source_variables.styl</strong> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">$winered= rgba(<span class="number">174</span>,<span class="number">50</span>,<span class="number">54</span>,<span class="number">0.85</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Layout sizes</span></span><br><span class="line"><span class="comment">// --------------------------------------------------</span></span><br><span class="line">$main-desktop= <span class="number">80</span>%</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Background color for &lt;body&gt;</span></span><br><span class="line">$body-bg-color= gainsboro</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Pagination</span></span><br><span class="line"><span class="comment">// --------------------------------------------------</span></span><br><span class="line">$pagination-link-hover-border   = $winered</span><br><span class="line">$pagination-active-bg           = $winered</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Buttons</span></span><br><span class="line"><span class="comment">// --------------------------------------------------</span></span><br><span class="line">$btn-<span class="keyword">default</span>-radius             = <span class="number">0</span></span><br><span class="line">$btn-<span class="keyword">default</span>-bg                 = white</span><br><span class="line">$btn-<span class="keyword">default</span>-color              = $winered</span><br><span class="line">$btn-<span class="keyword">default</span>-border-width       = <span class="number">1</span>px</span><br><span class="line">$btn-<span class="keyword">default</span>-border-color       = $winered</span><br><span class="line">$btn-<span class="keyword">default</span>-hover-bg           = $winered</span><br><span class="line">$btn-<span class="keyword">default</span>-hover-color        = white</span><br><span class="line">$btn-<span class="keyword">default</span>-hover-border-color = $winered</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 文章内链接文本样式</span></span><br><span class="line">.post-body p a&#123;</span><br><span class="line">  color: #<span class="number">0593</span>d3;</span><br><span class="line">  border-bottom: none;</span><br><span class="line">  border-bottom: <span class="number">1</span>px solid #<span class="number">0593</span>d3;</span><br><span class="line">  &amp;:hover &#123;</span><br><span class="line">    color: #fc6423;</span><br><span class="line">    border-bottom: none;</span><br><span class="line">    border-bottom: <span class="number">1</span>px solid #fc6423;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主页文章上下左右间距</span></span><br><span class="line">.post &#123;</span><br><span class="line"><span class="comment">// margin-top: 5px;</span></span><br><span class="line"><span class="comment">// margin-bottom: 3px;</span></span><br><span class="line">  padding: <span class="number">3</span>px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>10.修改**_config.yml** <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">涉及改动内容较多，在此不再赘述</span><br></pre></td></tr></table></figure></p><h1 id="hexo常用命令">Hexo常用命令</h1><blockquote><ol style="list-style-type: decimal"><li>清空工程，便于重新生成站点文件，改动涉及hexo框架内文件时使用 hexo clean</li></ol></blockquote><blockquote><ol start="2" style="list-style-type: decimal"><li>生成站点文件 hexo g</li></ol></blockquote><blockquote><ol start="3" style="list-style-type: decimal"><li>启动本地server，不更改port一般为<strong>http://localhost:4000</strong> hexo s</li></ol></blockquote><blockquote><ol start="4" style="list-style-type: decimal"><li>生成站点文件，并部署到github hexo g -d</li></ol></blockquote><h1 id="ubuntu18.04部署迁移hexo">Ubuntu18.04部署、迁移Hexo</h1><blockquote><p>第一步，安装 NodeJs <code>sudo apt install -y nodejs</code></p></blockquote><blockquote><p>第二步，安装 npm <code>sudo apt install -y npm</code> 如果提示node版本过低，可以执行下面方法升级node <code>node -v</code> #先查看本机node.js版本： <code>sudo npm install -g n</code> #安装node管理器n <code>sudo n stable</code> # 升级最新稳定版本</p></blockquote><blockquote><p>第三步，安装hexo <code>npm install -g hexo-cli</code></p></blockquote><blockquote><p>第三步，安装hexo <code>npm install -g hexo-cli</code> <strong>另：本地测试时，火狐浏览器会遇到证书问题</strong> preference -&gt; security -&gt; Block dangerous and deceptive content</p></blockquote><blockquote><p>第四步，迁移hexo，拷贝文件及文件夹 拷贝_config.yml，theme/，source/，scaffolds/，package.json，.gitignore 删除.git/，node_modules/，public/，.deploy_git/，db.json</p></blockquote><blockquote><p>第五步，hexo路径执行 <code>npm install</code> 迁移完成 <strong>迁移博客切勿执行<code>hexo init</code>，配置文件_config.yml里面内容会被清空使用默认值</strong></p></blockquote><blockquote><p>等后续有空后研究下利用docker镜像管理hexo的部署迁移</p></blockquote><h1 id="解决微相册图床问题">解决微相册图床问题</h1><p>next 主题，编辑主题目录下的 next/layout/_partials/head.swig 文件，在头部加入下面的 meta 标签 <code>&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot; /&gt;</code></p><h1 id="解决下一页图标问题">解决&quot;下一页&quot;图标问题</h1><p>修改代码的位置<code>themes\next\layout\_partials\pagination.swig</code> <code>&lt;i class=&quot;fa fa-angle-left&quot;&gt;&lt;/i&gt;</code> 修改为<code>&lt;</code> <code>&lt;i class=&quot;fa fa-angle-right&quot;&gt;&lt;/i&gt;</code> 修改为<code>&gt;</code></p><h1 id="解决公式符号和默认语法冲突的问题">解决公式符号和默认语法冲突的问题</h1><blockquote><p>第一步，卸载默认公式渲染引擎 <code>npm uninstall hexo-renderer-marked --save</code></p></blockquote><blockquote><p>第二步，安装Pandoc渲染引擎 <code>sudo apt-get install pandoc</code> <code>npm install hexo-renderer-pandoc --save</code></p></blockquote><blockquote><p>第三步，解决<code>hexo s</code>报错 修改代码的位置<code>node_modules\hexo-renderer-pandoc\index.js</code> <code>var args = [ '-f', 'markdown-smart'+extensions, '-t', 'html-smart', math]</code> 修改为 <code>var args = [ '-f', 'markdown'+extensions, '-t', 'html', math]</code></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;hexo-next主题定制化修改&quot;&gt;Hexo NexT主题定制化修改&lt;/h1&gt;
&lt;p&gt;折腾几天，总算是有了自己的Blog，也算是一个新的开始。 NexT主题的装修也零零散散花了些时间，期间也参考了不少其他博主的配置，总算 是部署成自己比较钟意的样式了。
    
    </summary>
    
      <category term="Blog" scheme="http://jxbuaa.github.io/categories/Blog/"/>
    
    
      <category term="Hexo" scheme="http://jxbuaa.github.io/tags/Hexo/"/>
    
      <category term="NexT" scheme="http://jxbuaa.github.io/tags/NexT/"/>
    
      <category term="Theme" scheme="http://jxbuaa.github.io/tags/Theme/"/>
    
  </entry>
  
</feed>
